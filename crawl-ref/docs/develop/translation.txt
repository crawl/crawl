Guide to translating Crawl's text
=================================

There are three sets of text files. They are in the following directories:

1. crawl-ref/source/dat/descript
2. crawl-ref/source/dat/database
3. crawl-ref/source/dat/strings

The English files are in the directory itself (for #1 and #2 only. #3 has no English files) .

The equivalent files for other languages go in a subdirectory named with the
2-letter ISO code for that language (e.g. de for German, fr for French, es for
Spanish, etc.)

Entries in the files are separated by %%%%. The first line in each entry is the
lookup key. Do NOT translate the key, only the rest of the text.

Sometimes, there are placeholders for named parameters like @the_monster@.
Do not translate the parameter name. If you wish the parameter value to be
capitalised (for example, if you've moved it to the start of a sentence) then
capitalise the first letter: @The_monster@.

You will also sometimes see embedded Lua code. In general, you don't want to
change the code, just the text strings contained within it. Although, there
may be cases where you need to change the logic.

Do not put whitespace at the end of lines.


A description of the different file sets:


1. crawl-ref/source/dat/descript
--------------------------------

These hold verbose description text for various things in the game (items, monsters, etc.).

By convention, the max line length is 80 characters. However, the lines will be
concatenated by the program. Do not put whitespace at the end of lines (when the
program joins the lines, it will add a space where the line break was.) If you
want the program to include a line break then leave a blank line. Generally, you
will want to follow the English text in this regard.

The translation of the quotes.txt file is optional since it's just flavour text
(quotes from books, etc.) without any game-relevant information.


2. crawl-ref/source/dat/database
--------------------------------

There are a couple of different kinds of files in here.

Some are used for random monster/item name generation. I recommend against
translating these. They are monname.txt and rand*.txt.

The rest contain sets of messages that are randomly selected from when some event
happens. For example, when a monster speaks or casts a spell. Translate these.

There are a lot of placeholders in here that reference other entries.
The way they are used for English may not work for the target language, so you
may need to re-work that aspect.


3. crawl-ref/source/dat/strings
--------------------------------

These hold translations for English strings hardcoded in the game code.
Therefore, there are no files for English itself, only for other languages.
The keys are the actual English strings that are displayed to the user.

If the string includes leading or trailing whitespace, it must be surrounded
with double-quotes ("). Generally, you will want to keep any such whitespace
the same as in the English version.


The following sections apply to crawl-ref/source/dat/strings only...


printf-style placeholders (%s, etc.)
------------------------------------

In addition to placeholders like @the monster@, you will also see printf-style
placeholders that start with a percent sign:
%s = string (i.e. text)
%c = single character
%d, %i = integer
%u = unsigned integer
%f, %g = floating-point number
%% = percent sign

Sometimes, these placeholders will have extra qualifiers in them. For example:
%.1f = floating-point number with one (and only one) digit after the decimal point
%2d = integer with a field width of 2 (if it's a single-digit number, it will be padded with a leading space)

There are more complicated examples as well. See here for a full explanation of the format:
https://cplusplus.com/reference/cstdio/printf

Generally, you will want to leave these placeholders alone. However, if you need
to use them in a different order than in the English string, you must include
the parameter number directly after the %, and followed by $, for **every**
parameter. For example:

%%%%
%s %d times for up to %d damage each
%2$d Mal %1$s für bis zu %3$d Schaden pro Mal
%%%%


context modifiers
-----------------

You can define specific translation contexts at will. They are specifed with
curly braces.

These can be used to handle gender and/or grammatical case. This is best
explained by example. See below.


Handling grammatical gender
---------------------------

Suppose I defined this adjective in French:

%%%%
"large "
"grand "
%%%%

If I then add a string with a placeholder for the adjective:

%%%%
%sgate
%sportail
%%%%

I would get "grand portail" displayed, as required. However, if I do this:

%%%%
%sdoor
%sporte
%%%%

I would get "grand porte", which is incorrect, since porte is feminine. It should
be "grande porte".

To get around this, I can define a specific translation for "large " in the feminine
context, like this:

%%%%
"{f}large "
"grande "
%%%%

(I have chosen {f} for brevity, but you could use {fem} or whatever you want.)

Then for "door", I do:

%%%%
%sdoor
{f}%sporte
%%%%

This will give "grande porte".

You could define specific contexts for each gender, like this:

%%%%
"{m}large "
"grand "
%%%%
"{f}large "
"grande "
%%%%

However, it's recommended to make one of them the default, by defining the
strings without a specific context, like this:

%%%%
"large "
"grand "
%%%%
"{f}large "
"grande "
%%%%

The reason being that the program will fall back to the default context if it
can't find a translation in the specific context or if no context is specified,
but if it can't find a default translation, it will fall back to English.
Getting a word with the wrong gender is probably preferable to getting a word in
the wrong language.

You can choose any gender as the default one, but it's best to choose one and
stick to it (treating masculine as default in one place, and feminine as the
default in another would probably cause issues at some point).


Handling grammatical case
---------------------------

Suppose I had this entry for German:

%%%%
the orc
der Ork
%%%%

This works fine in the following sentence:

%%%%
%s hits you.
%s trifft Euch.
%%%%

It would be rendered as "Der Ork trifft Euch." (The first letter of the sentence
will be automatically capitalised.)

However, it won't work with the following sentence:

%%%%
You hit %s.
Ihr trefft %s.
%%%%

It would be rendered as "Ihr trefft der Ork.", which is grammatically incorrect.
It should use the accusative case: "Ihr trefft den Ork."

To get around this, we use a context modifier to define "the orc" in accusative:

%%%%
{acc}the orc
den Ork
%%%%

(I have used {acc} here, but you can use whatever you want.)

Then we define our sentence as:

%%%%
You hit %s.
Ihr trefft {acc}%s.
%%%%

This will render a grammatically-correct sentence.

As with gender, you could define a specific context for every case, but I
recommend making one case (normally nominative) the default. This saves a lot
of work, since the nominative is used in most instances. Also, if the program
can't find a translation in the specific context, it will fall back to the
default context, but if there's no translation in the default context, it falls
back to English. Having a word in the wrong case is probably preferable to
having a word in the wrong language.


Defining grammatical rules
--------------------------

Manually defining translations for each context can be tedious. Declining
nouns in all the cases is especially hard work, since in addition to
"the mace", you have to translate "a mace", "your mace", and "%d maces".
Multiply that by four or five grammatical cases, and you have a lot of strings
to translate.

For that reason, it's possible to define rules for transforming strings from
the default context into another context. These rules use something called
"regular expressions". Regular expressions are very powerful, but also very
complex. If you're not familiar with them, you will probably want to google for
an explanation of how they work. However, some simple examples are given below.

Here is a simple example for the declension of German nouns in accusative:

%%%%
GENERATE:acc
/der/den/
%%%%

This means, replace all instances of "der" with "den". This would transform
"der Ork" into "den Ork", as we want.

Hang on though, all instances are replaced, so it would transform "der Ring
der Intelligenz" into "den Ring den Intelligenz". That's not what we want. We
only want to replace the first "der".

To fix this, we can use ^ to match the start of the string:

%%%%
GENERATE:acc
/^der/den/
%%%%

This will give us "den Ring der Intelligenz", which is what we want.

We also want to make sure we only do the replacement for the whole word "der",
and not for some word that happens to start with those letters. One way to
achieve this would be to include the space in the pattern and replacement:

%%%%
GENERATE:acc
/^der /den /
%%%%

Another possibility is to use \b, which matches a word boundary.

%%%%
GENERATE:acc
/^der\b/den/
%%%%

Note that the \b match does not include the following space, so we do not
include the space in the replacement.

By the way, the counterpart to ^ is $, which matches the end of the string.

A rule can contain multiple expressions. For example, for German dative, you
might have:

%%%%
GENERATE:dat
/^der\b/dem/
/^das\b/dem/
/^die\b/der/
%%%%

Note that the expressions are applied sequentially, so order is important. In
this example, if we put the "die" to "der" replacement first, the "der" would
subsequently be replaced with "dem", which is not what we want.

There is also another expression format with three elements. In this format, the
first element says "only apply the replacement to the substring that matches
this pattern".

For example, suppose we wanted to add adjective declension to our German
dative example. We want to replace e at the end of the word with en. This is
easy; we just use /e\b/en/, right? Wait though, we only want to do this for
adjectives, not for nouns. We also do not want to apply this to any words after
the noun. We want "die verfluchte Gleve der Prünelle" to become 
"der verfluchten Gleve der Prünelle", not "der verfluchten Gleven der Prünellen".
"Prünellen" we can fix by using /e /en / instead of /e\b/en/, but we're
still going to get "Gleven".

Since we know that German nouns always start with an uppercase letter, but
adjectives do not, we can do this:

%%%%
GENERATE:dat
/^der\b/dem/
/^das\b/dem/
/^die\b/der/
/^(dem|der) [a-zäöüß\- ]+/e\b/en/
%%%%

(dem|der) matches either "dem" or "der". (Remember that this is applied after
the preceeding replacements have been done.)

The part in square brackets matches any character within them. A hyphen
specifies a range of characters, so a-z means any character from a to z. Since
the hyphen is used to specify a range, we must use \- to match an actual hyphen.
The space matches space.

The + means "one or more". To match zero or more, use *. To match zero or one,
use ?. If none of these are present, it means match one only.

Instead of [a-zäöüß\- ], we could've used [^A-ZÄÖÜ]. The ^ in this context,
means "not", so this matches anything that is not an uppercase letter.

Putting it all together, this expression means apply the replacement /e\b/en/
only to the part that is the word "der" or "dem" at the start of the string
followed by words that are in all lowercase. The first noun and anything
following is excluded because the match stops when it hits an uppercase letter.

You can explicitly define exceptions to these rules. For example, the above
rules would not work for the string "Blork der Ork", because the article "der"
is not at the start, so we would decline that particular string explicitly:

%%%%
Blork the orc
Blork der Ork
%%%%
{acc}Blork the orc
Blork den Ork
%%%%
{dat}Blork the orc
Blork dem Ork
%%%%

