################################################################################
#  Layouts for The Vaults
#
#  Code by infiniplex
#  With help from several people
#  Original idea by mumra
#  Discussion:
#    -> Vaults page on the development wiki
#    -> https://crawl.develz.org/tavern/viewtopic.php?f=8&t=5008
#
#  These layouts all depend heavily on subvaults.  The basic
#    idea is to place hallways with rooms attached to them and
#    to fill each room with a subvault.  The subvaults are
#    assigned to rooms randomly, based on probabilities.  The
#    layout generator allows some variation in how many of each
#    room content type are chosen, but not too much.  This
#    prevents random numbers causing the occasional extreamly
#    unbalanced layout.
#
#  The code to generate these layouts is complex and difficult
#    to understand.  To allow them to be adapted more easily,
#    there is a dedicated set of constants and functions to
#    allow the layouts to be modified.
#
#  Commands to add new room sizes or room content types are
#    marked with <|>s to make them easier to find.
#
#
#  The layouts change based on depth, although there is a lot
#    of variation.  In general, a deeper map has:
#      -> fewer, wider hallways
#      -> larger rooms
#      -> more orderly rooms
#
#  There are 8 conceptual layouts.  The layout types are:
#      -> layout_vaults_city
#           -> rooms in an orderly grid with hallways around and
#              between them
#           -> all rooms are the same size
#      -> layout_vaults_chaotic_city
#           -> rooms placed all over a big open room
#      -> layout_vaults_grid
#           -> a grid of rooms
#           -> rooms may be connected directly or may have
#              hallways
#           -> all rooms are the same size
#      -> layout_vaults_cross
#           -> a hallway in a cross with rooms on both sides
#      -> layout_vaults_walkways
#           -> a main hallway crossed by smaller hallways and
#              rooms on both sides of the smaller hallways
#      -> layout_vaults_square_ring
#           -> a hallway in a square rooms rooms on the inside
#              and outside of the hallway
#      -> layout_vaults_square_ring_huge_center
#           -> a hallway in a square rooms rooms on the outside
#              and a huge room in the center
#          -> these are in tribute to st's giant box vaults
#      -> layout_vaults_square_ring_chaotic city
#           -> a hallway in a square rooms rooms on the outside
#              and a chaotic city inside
#
#  There are several room types use by the layout generator.
#    Instructions on how to change their frequencies and add new
#    types appear below.  The basic room types are:
#      <0> empty
#           -> furniture/flavour/story rooms
#           -> no loot or monsters (except as needed for
#              thematic purposes)
#      <1> encounter_normal
#           -> this is a standard-strength encounter
#           -> it could have some loot
#      <2> encounter_hard
#           -> this is a more dangerout encounter
#           -> these might have better loot
#      <3> loot
#           -> a vault that primarily contains loot
#           -> these are placed rarely (5% or less)
#
#  There are also room types used internally:
#      <4> vanishing
#           -> this room (including walls) is not added
#           -> this is used by the city layout
#      <5> hallway
#           -> this room is replaced by a hallway connected to
#              other rooms on the correct sides
#           -> this is used by the maze layout
#      <6> solid wall
#           -> this room is filled with walls
#           -> this is used to reduce the number of rooms
#
#  There are also some special room types.  These have to go
#    last for internal reasons.  The types are:
#      <7> stairs_up_3
#      <8> stairs_down_3
#           -> this room contains 3 staircases up/down
#      <9> stairs_up_1A
#      <10>stairs_down_1A
#      <11>stairs_up_1B
#      <12>stairs_down_1B
#      <13>stairs_up_1C
#      <14>stairs_down_1C
#           -> this room contains 1 staircases up/down
#           -> the layout generator will place one of each
#           -> these all use the same two kinds of subvaults
#      <15>branch_crypt
#           -> this room contains the entrance to the Crypt
#      <16>branch_hall
#           -> this room contains the entrance to the Hall of
#             Blades
#      <17>portal_bazaar
#      <18>portal_bazaar
#      <19>portal_bazaar
#      <20>portal_bazaar
#      <21>portal_bazaar
#           -> these room contains the entrance to the indicated
#              portal vault
#
#
#  The rooms are all square and have a size group (which is used
#    as an array index).  The current room sizes are:
#      <0> 1x1 (closets)
#      <1> 4x4
#      <2> 7x7
#      <3> 10x10
#      <4> 15x15
#
#
#  In this file, I have used the following naming conventions:
#    -> All constants are in ALL_CAPS_WITH_UNDERSCORES.
#    -> All arrays (tables with consecutive numeric indicies
#       starting at 0) with a_ (or A_).  A 2D array is prefixed
#       with aa_ (or AA_).
#
#  I originally wrote this in C++ (better debugging support) and
#    I have usually copied in the function documentation
#    directly.  This means that there is the occasional
#    reference in that documentation to something that does not
#    exist in LUA.  For example, arrays passed as function
#    parameters are allegedly checked against NULL, not nil.
#    Such things can be ignored.  I have, however, left the
#    array numbering as starting from 0.
#





################################################################################
#  Constants and Confinguration Functions
#
#  These are the variables and functions used to configure the
#    layouts.  It should be possible to make the layouts do
#    more-or-less whatever with these.
#
#  Actually, all file constants are here.  The descriptions
#    should indicate which ones are configuration values and
#    which ones are have to keep their values.
#

{{
PRINT_LAYOUT_STATISTICS = false
}}



########
#  Stuff about Map Depth
#
#  This functions are used in the configuration functions.
#    It should probably should be left alone.
#
#
#  getDepthFraction
#
#  Purpose: To determine what fraction of the total depth of
#           the branch the specified depth represents.  This
#           function returns 0.0 at a depth of 1 and reaches
#           0.999999 on the second deepest level of the branch.
#           The deepest level is assumed to have a special
#           encompass vault instead of a normal layout.
#  Parameter(s):
#      <1> depth: The depth of the map within the branch
#  Preconditon(s): N/A
#  Returns: The fraction of the total depth of the branch.
#           This is always a value in the range [0, 1).
#  Side Effect: N/A
#

{{
function getDepthFraction (depth)
  if depth < 1 then
    return 0
  elseif depth >= dgn.br_depth(you.branch()) - 1 then
    return 0.999999
  else
    return (depth - 1) / (dgn.br_depth(you.branch()) - 2)
  end
end
}}



########
#  Stuff about Choosing Layouts
#
#  There is only one "real" layout, in the sense of a layout the
#    Crawl understands.  This stuff is used to choose which
#    conceptual layout should be generated.  They are not made
#    into seperate "real" layouts so that the frequencies of
#    each can vary with depth.
#
#
#  ROOM_GROUP_STYLE_CONSTANT, ROOM_GROUP_STYLE_VARIABLE, and
#    ROOM_GROUP_STYLE_SCRAMBLED are constants representing the
#    differant stiles of room groups that can be chosen.  See
#    the secotion for room groups for an explanation of these.
#

{{
ROOM_GROUP_STYLE_CONSTANT  = 0
ROOM_GROUP_STYLE_VARIABLE  = 1
ROOM_GROUP_STYLE_SCRAMBLED = 2
}}

#
#  LAYOUT_STYLE_CITY, LAYOUT_STYLE_CHAOTIC_CITY,
#    LAYOUT_STYLE_GRID, LAYOUT_STYLE_CROSS,
#    LAYOUT_STYLE_WALKWAYS, LAYOUT_STYLE_SQUARE_RING,
#    LAYOUT_STYLE_SQUARE_RING_CHAOTIC_CITY, and
#    LAYOUT_STYLE_SQUARE_RING_HUGE_CENTER represent the
#    different conceptual layouts.  LAYOUT_STYLE_MAZE is a
#    variant on LAYOUT_STYLE_GRID with hallways replacing some
#    of the rooms.
#

{{
LAYOUT_STYLE_CITY                     = 0
LAYOUT_STYLE_CHAOTIC_CITY             = 1
LAYOUT_STYLE_GRID                     = 2
LAYOUT_STYLE_MAZE                     = 3
LAYOUT_STYLE_CROSS                    = 4
LAYOUT_STYLE_WALKWAYS                 = 5
LAYOUT_STYLE_SQUARE_RING              = 6
LAYOUT_STYLE_SQUARE_RING_CHAOTIC_CITY = 7
LAYOUT_STYLE_SQUARE_RING_HUGE_CENTER  = 8
}}

#
#  getStyle
#
#  Purpose: To determine the style of room group selection and
#           the conceptual layout to use for a map at the
#           specified depth.
#  Parameter(s):
#      <1> depth: The depth of the map within the branch
#  Preconditon(s): N/A
#  Returns:
#       <1> The conceptual layout
#       <2> The room group selection style
#  Side Effect: N/A
#
#  LUA lets you return mutiple values with one function
#

{{
function getStyle (depth)

  -- 4 + 2 + 3 + 3 + 3 + 5 = 20
  local OPTION_COUNT = 20

  -- Note: No scrambled form of the square ring huge center layout
  local A_LAYOUT_STYLES = {
    -- city and chaotic city
      [0]=LAYOUT_STYLE_CITY,
          LAYOUT_STYLE_CHAOTIC_CITY,
          LAYOUT_STYLE_CHAOTIC_CITY,
          LAYOUT_STYLE_CHAOTIC_CITY,
    -- grid and maze
          LAYOUT_STYLE_GRID,
          LAYOUT_STYLE_MAZE,
    -- cross
          LAYOUT_STYLE_CROSS,
          LAYOUT_STYLE_CROSS,
          LAYOUT_STYLE_CROSS,
    -- walkways
          LAYOUT_STYLE_WALKWAYS,
          LAYOUT_STYLE_WALKWAYS,
          LAYOUT_STYLE_WALKWAYS,
    -- basic square ring
          LAYOUT_STYLE_SQUARE_RING,
          LAYOUT_STYLE_SQUARE_RING,
          LAYOUT_STYLE_SQUARE_RING,
    -- special square ring
          LAYOUT_STYLE_SQUARE_RING_CHAOTIC_CITY,
          LAYOUT_STYLE_SQUARE_RING_CHAOTIC_CITY,
          LAYOUT_STYLE_SQUARE_RING_CHAOTIC_CITY,
          LAYOUT_STYLE_SQUARE_RING_HUGE_CENTER,
          LAYOUT_STYLE_SQUARE_RING_HUGE_CENTER
    }

  local A_ROOM_GROUP_STYLES = {
    -- city and chaotic city
      [0]=ROOM_GROUP_STYLE_CONSTANT,
          ROOM_GROUP_STYLE_CONSTANT,
          ROOM_GROUP_STYLE_VARIABLE,
          ROOM_GROUP_STYLE_SCRAMBLED,
    -- grid and maze
          ROOM_GROUP_STYLE_CONSTANT,
          ROOM_GROUP_STYLE_CONSTANT,
    -- cross
          ROOM_GROUP_STYLE_CONSTANT,
          ROOM_GROUP_STYLE_VARIABLE,
          ROOM_GROUP_STYLE_SCRAMBLED,
    -- walkways
          ROOM_GROUP_STYLE_CONSTANT,
          ROOM_GROUP_STYLE_VARIABLE,
          ROOM_GROUP_STYLE_SCRAMBLED,
    -- basic square ring
          ROOM_GROUP_STYLE_CONSTANT,
          ROOM_GROUP_STYLE_VARIABLE,
          ROOM_GROUP_STYLE_SCRAMBLED,
    -- special square ring
          ROOM_GROUP_STYLE_CONSTANT,
          ROOM_GROUP_STYLE_VARIABLE,
          ROOM_GROUP_STYLE_SCRAMBLED,
          ROOM_GROUP_STYLE_CONSTANT,
          ROOM_GROUP_STYLE_VARIABLE
    }

  local A_PERCENT_AT_TOP = {
    -- 25% chance for city and chaotic city
      [0]=2,
          3,
          8,
          12,
    -- 20% chance for grid and maze
          5,
          15,
    -- 15% chance for cross
          2,
          8,
          5,
    -- 15% chance for walkways
          2,
          8,
          5,
    -- 15% chance for basic square ring
          2,
          8,
          5,
    -- 10% chance for special square ring
          1,
          3,
          3,
          1,
          2
    }

  local A_PERCENT_AT_BOTTOM = {
    -- 25% chance for city and chaotic city
      [0]=20,
          5,
          0,
          0,
    -- 20% chance for grid and maze
          20,
          0,
    -- 15% chance for cross
          10,
          5,
          0,
    -- 15% chance for walkways
          10,
          5,
          0,
    -- 15% chance for basic square ring
          10,
          5,
          0,
    -- 10% chance for special square ring
          2,
          1,
          0,
          5,
          2
    }

  local depth_fraction = getDepthFraction(depth)
  local a_frequency_at_depth = {}
  local total_frequency = 0
  for i = 0, OPTION_COUNT - 1 do
    local top_fraction    = A_PERCENT_AT_TOP[i]    * (1 - depth_fraction)
    local bottom_fraction = A_PERCENT_AT_BOTTOM[i] *      depth_fraction
    a_frequency_at_depth[i] = math.floor(top_fraction + bottom_fraction + 0.5)
    total_frequency = total_frequency + a_frequency_at_depth[i]
  end

  local chosen = crawl.random2(total_frequency)
  for i = 0, OPTION_COUNT - 1 do
    chosen = chosen - a_frequency_at_depth[i]

    if chosen < 0 then
      return A_LAYOUT_STYLES[i], A_ROOM_GROUP_STYLES[i]
    end
  end

  crawl.mpr("Error: How did we get here?")
  return LAYOUT_STYLE_CITY, ROOM_GROUP_STYLE_CONSTANT
end
}}

#
#  There can be center rooms of various sizes for the
#    square ring huge center layout.  For consistancy, the
#    larger dimension of a non-square rooms size should be
#    specified first.
#
#  <|>
#  To add a new size for the center room:
#    <1> Modify  the getHugeCenterSize function to have a chance
#        of returning the new size.
#    <2> Add one or more subvaults of that size, including at
#        least one with the allow_dup tag.
#
#
#  getHugeCenterSize
#
#  Purpose: To determine the size of the huge center rooms for
#           the suare ring huge center layout.
#  Parameter(s):
#      <1> depth: The depth of the map within the branch
#  Preconditon(s): N/A
#  Returns:
#       <1> The size in the x dimension
#       <2> The size in the 7 dimension
#  Side Effect: N/A
#
#  LUA lets you return mutiple values with one function
#

{{
function getHugeCenterSize(depth)
  -- only one option so far
  return 30, 20
end
}}



########
#  Information on Map Sizes
#
#  The layouts attempt to generate the largest map that they
#    can, based on the sizes of the rooms.  Becuase of this,
#    smaller rooms result in larger maps.  To offset this, the
#    effective maximum map size is randomly reduced at lower
#    depths.  At deeper depths, the larger rooms reduce the
#    size of the map on their own.
#
#  MAP_SIZE is the real maximum map size.  Becuase all layouts
#    are square, this is equal to the smaller of the maximum
#    width and height.
#

{{
MAP_SIZE = math.min(dgn.max_bounds())
}}

#
#  getMaximumMapSize
#
#  Purpose: To determine the effective maximum map size.  This
#          may be smaller than MAP_SIZE.
#  Parameter(s):
#      <1> depth: The depth of the map within the branch
#  Preconditon(s): N/A
#  Returns: The maximum map size.  This function is not
#          deterministic, so do not call it more than once
#          and expect the same value.
#  Side Effect: N/A
#

{{
function getMaximumMapSize (depth)
  local depth_fraction = getDepthFraction(depth)
  local percent_from_bottom = (1.0 - depth_fraction) * 100
  local percent_smaller = crawl.random2(percent_from_bottom) * 0.25
  return math.floor(MAP_SIZE * (1.0 - percent_smaller * 0.01))
end
}}



########
#  Information on Hallway Sizes
#
#  There is a minimum hallway size that increases with depth.
#    In addition, the hallways in a map may be larger than that
#    minimum size.  Exceptions are the city layout, where the
#    minimum hallway size is always used, and the grid layout,
#    which has no hallways, and the maze layout, where hallway
#    size is based on the size of a door to a room.
#
#  Increasing the minimum hallway size at deeper depths runs the
#    risk of breaking layouts.  The city layout is probably the
#    most vulnerable.
#
#
#  getMinimumHallwaySize
#
#  Purpose: To determine the minimum hallway size for the
#          specified depth.
#  Parameter(s):
#      <1> depth: The depth of the map within the branch
#  Preconditon(s): N/A
#  Returns: The minimum size for hallways at depth depth.
#  Side Effect: N/A
#

{{
function getMinimumHallwaySize (depth)
  local depth_fraction = getDepthFraction(depth)
  return 1 + math.floor(depth_fraction * 3)
end
}}

#
#  getRandomHallwaySize
#
#  Purpose: To determine a random hallway size for the
#          specified depth.
#  Parameter(s):
#      <1> depth: The depth of the map within the branch
#  Preconditon(s): N/A
#  Returns: A random hallway size appropriate for depth depth.
#  Side Effect: N/A
#

{{
function getRandomHallwaySize (depth)
  local MAX_EXTRA_SIZE = 4

  local extra_size = math.floor(crawl.random2(MAX_EXTRA_SIZE))
  return getMinimumHallwaySize(depth) + extra_size
end
}}



########
#  Information on Room Sizes
#
#  <|>
#  To add a new room size:
#      <1> Increase ROOM_GROUP_COUNT by 1
#      <2> Add a new element to A_ROOM_SIZE and A_DOOR_SIZE
#      <3> Update setGroupFrequencyConstant,
#                 setGroupFrequencyVariable, and
#                 setGroupFrequencyScrambled
#      <4> Update A_CONTENT_HALLWAY_FREQUENCY_MAZE,
#                 A_CONTENT_SOLID_FREQUENCY_MAZE,
#                 A_CONTENT_SOLID_FREQUENCY_GRID, and the array
#          in the getContentSolidFrequencyWalkways function
#      <5> Update the room size list in vaults_rooms.des
#      <6> Add the appropriate subvaults for each door type and
#          content type
#
#  WARNING: Adding larger rooms sizes (greater than 15x15) may
#    cause one or more of the layout generator alogorithms to
#    crash.  This will occur if they cannot find a way to get
#    enough rooms on a map.  The most likely crash candidate is
#    layout_city, which requires at least 3 by 3 rooms to be
#    generated.
#
#  The size of a room is how many glyphs across it is,
#    excluding the walls and the door.  The group (or size
#    group) for a room is the array index for that size.
#    Internally, rooms are refered to by group and the size is
#    calculated when the rooms are drawn to the map.
#
#  Room sizes are chosen before the map is generated using one
#    of three styles, each with a corresponding function.  Note
#    that there is no guarentee of getting at least one room
#    with each possible size.  The styles are:
#      -> Constant: all rooms on the map have the same size
#      -> Variable: rooms have 1 of 2 sizes
#      -> Scrambled: rooms have 1 of 3 or more sizes
#
#  ROOM_GROUP_COUNT is the number of room groups.
#
#  A_ROOM_SIZE is an array of the sizes of the rooms, indexed by
#    the room group.
#
#  ROOM_GROUP_CLOSET is a constant indicating that a room has a
#    size group of a closet (1x1).  This size group is handled
#    specially in many places.
#
#  ROOM_GROUP_FIRST_NON_CLOSET is a constant indicating the
#    first size group for rooms that is not a closet.  This is
#    needed because some layouts require rooms not to be closets
#    in some cases.  For example, the city (not chaotic city)
#    layout never generates closets.
#
#  A_DOOR_SIZE is an array containg the size of the block
#    reserved for the door of the room.  This is the number of
#    glyphs reserved for the door in the subvault.  The actual
#    size of the door may be smaller, as some of these glyphs
#    may be filled with wall.
#
#  Each element of the A_DOOR_SIZE array must be less than the
#    size of the corresponding room (except for 1x1 closets,
#    which are equal and handled specially).  The differance
#    the size of the room and the size of the door must be
#    between even.  For example, if the room size is 7, the door
#    size must be one of 1, 3, 5, and 7.  It cannot be 9 because
#    that is larger than the room, and it cannot be 4 becuase
#    the differance is not even.
#
#  The door cannot be the full size of the room becuase the
#    shape of the room is used to orient the subvault.  A room
#    with a door of the same size whould allow the subvault to
#    be put in backwards, with the door in the back.
#

{{
ROOM_GROUP_COUNT = 5
ROOM_GROUP_CLOSET = 0
ROOM_GROUP_FIRST_NON_CLOSET = 1
A_ROOM_SIZE = { [0]=1, 4, 7, 10, 15 }
A_DOOR_SIZE = { [0]=1, 2, 3,  4, 7 }
}}

#
#  getGroupFrequencyArrayConstant
#  getGroupFrequencyArrayVariable
#  getGroupFrequencyArrayScrambled
#
#  Purpose: To generate the room group frequency table for a
#          map of the indicated strategy at the specified
#          depth.
#  Parameter(s):
#      <1> depth: The depth of the map
#  Preconditon(s): N/A
#  Returns: The array of the frequencies of the room groups.
#          The "total" field (all right, it's not an array) is
#          set to contain the sum of the frequencies.  No
#          frequency is negative. The total is at least 1.
#  Side Effect: N/A
#

{{
function getGroupFrequencyArrayConstant(depth)
  local FREQUENCY_COUNT = 7
  local AA_ROOM_GROUP_FREQUENCY =
  { [0]={ [0]=   0,    1,    0,    0,    0  },
        { [0]=   0,    0,    1,    0,    0  },
        { [0]=   0,    0,    1,    0,    0  },
        { [0]=   0,    0,    0,    1,    0  },
        { [0]=   0,    0,    0,    1,    0  },
        { [0]=   0,    0,    0,    0,    1  },
        { [0]=   0,    0,    0,    0,    1  } }
  --            1x1   4x4   7x7  10x10 15x15

  local a_group_frequency = {}
  local depth_fraction = getDepthFraction(depth)

  local random_value = crawl.random2(3000) / 10000
  local effective_depth_fraction = depth_fraction * 0.7 + random_value
  local frequency_index = effective_depth_fraction * FREQUENCY_COUNT
  frequency_index = math.floor(frequency_index)

  a_group_frequency.total = 0
  for i = 0, ROOM_GROUP_COUNT - 1 do
    a_group_frequency[i] = AA_ROOM_GROUP_FREQUENCY[frequency_index][i]
    a_group_frequency.total = a_group_frequency.total + a_group_frequency[i]
  end

  assert(a_group_frequency.total > 0)
  return a_group_frequency
end

function getGroupFrequencyArrayVariable(depth)
  local ROOM_GROUP_VARIATION = 2
  local NONE = -1000
  local FREQUENCY_COUNT = 10
  -- this array starts at index 1
  local AA_ROOM_GROUP_FREQUENCY =
  { [0]={ [0]=NONE,    2,    2, NONE, NONE },
        { [0]=NONE,    1,    3, NONE, NONE },
        { [0]=NONE,    2, NONE,    2, NONE },
        { [0]=NONE, NONE,    3,    1, NONE },
        { [0]=NONE, NONE,    2,    2, NONE },
        { [0]=NONE, NONE,    1,    3, NONE },
        { [0]=NONE, NONE,    2, NONE,    2 },
        { [0]=NONE, NONE, NONE,    3,    1 },
        { [0]=NONE, NONE, NONE,    2,    2 },
        { [0]=NONE, NONE, NONE,    1,    3 } }
  --            1x1   4x4   7x7  10x10 15x15

  local a_group_frequency = {}
  local depth_fraction = getDepthFraction(depth)

  local random_value = crawl.random2(3000) / 10000
  local effective_depth_fraction = depth_fraction * 0.7 + random_value
  local frequency_index = effective_depth_fraction * FREQUENCY_COUNT
  frequency_index = math.floor(frequency_index)

  a_group_frequency.total = 0
  for i = 0, ROOM_GROUP_COUNT - 1 do
    a_group_frequency[i] = AA_ROOM_GROUP_FREQUENCY[frequency_index][i]

    if a_group_frequency[i] == NONE then
      a_group_frequency[i] = 0
    else
      a_group_frequency[i] = a_group_frequency[i] +
                             crawl.random2(ROOM_GROUP_VARIATION)

      if a_group_frequency[i] < 0 then
        a_group_frequency[i] = 0
      end
    end

    a_group_frequency.total = a_group_frequency.total + a_group_frequency[i]
  end

  assert(a_group_frequency.total > 0)
  return a_group_frequency
end

function getGroupFrequencyArrayScrambled(depth)
  local ROOM_GROUP_VARIATION = 2
  local NONE = -1000
  local FREQUENCY_COUNT = 11
  -- this array starts at index 1
  local AA_ROOM_GROUP_FREQUENCY =
  { [0]={ [0]=   3,    4,    4,   -3, NONE },
        { [0]=   0,    3,    5,   -1, NONE },
        { [0]=  -3,    2,    6,    1, NONE },
        { [0]=NONE,    1,    4,    3,   -3 },
        { [0]=NONE,    1,    5,    5,   -1 },
        { [0]=NONE,   -1,    3,    4,    1 },
        { [0]=NONE,   -3,    2,    5,    2 },
        { [0]=NONE, NONE,    1,    4,    3 },
        { [0]=NONE, NONE,   -1,    3,    4 },
        { [0]=NONE, NONE,   -2,    1,    5 },
        { [0]=NONE, NONE,   -3,    0,    6 } }
  --            1x1   4x4   7x7  10x10 15x15

  local a_group_frequency = {}
  local depth_fraction = getDepthFraction(depth)

  local random_value = crawl.random2(3000) / 10000
  local effective_depth_fraction = depth_fraction * 0.7 + random_value
  local frequency_index = effective_depth_fraction * FREQUENCY_COUNT
  frequency_index = math.floor(frequency_index)

  a_group_frequency.total = 0
  for i = 0, ROOM_GROUP_COUNT - 1 do
    a_group_frequency[i] = AA_ROOM_GROUP_FREQUENCY[frequency_index][i]

    if a_group_frequency[i] == NONE then
      a_group_frequency[i] = 0
    else
      a_group_frequency[i] = a_group_frequency[i] +
                             crawl.random2(ROOM_GROUP_VARIATION)

      if a_group_frequency[i] < 0 then
        a_group_frequency[i] = 0
      end
    end

    a_group_frequency.total = a_group_frequency.total + a_group_frequency[i]
  end

  assert(a_group_frequency.total > 0)
  return a_group_frequency
end
}}

#
#  getRandomGroup
#
#  Purpose: To calculate a random room group based on the
#          frequencies in the specified frequency array.
#  Parameter(s):
#      <1> a_group_frequency: The array of frequencies
#  Preconditon(s):
#      <1> a_group_frequency != NULL
#      <2> a_group_frequency[ROOM_GROUP_COUNT] > 0
#  Returns: The array index corresponding to the chosen room
#          group.  This is a value in the range
#          [0, ROOM_GROUP_COUNT).
#  Side Effect: N/A
#

{{
function getRandomGroup (a_group_frequency)
  assert(a_group_frequency ~= nil,
         "a_group_frequency cannot == nil")
  assert(a_group_frequency.total > 0,
         "total frequency must be > 0")

  local chosen = crawl.random2(a_group_frequency.total)
  for i = 0, ROOM_GROUP_COUNT - 1 do
    chosen = chosen - a_group_frequency[i]
    if chosen < 0 then
      return i
    end
  end

  assert(false, "Error chosing random room group: chosen" .. chosen)
  return ROOM_GROUP_COUNT - 1
end
}}

#
#  getRandomGroupCorner
#
#  Purpose: To calculate a random room group.  The group is
#           calculated based on the frequencies in the
#           specified frequency array, but is weighted towards
#           large room groups to a degree based on depth.
#           In most cases, the corner room must be the largest
#           chosen to avoid collisions.  Thus, a stronger
#           weighting will increase the variation in room size.
#           However, forcing the map generator to pick a large
#           distribution to insist always force the creation of
#           room disproportionately often reduces the chance of
#           generating smaller rooms.  This is an issue with
#           larger rooms, where the total number of rooms
#           placed is small.
#  Parameter(s):
#      <1> depth: The depth of the map within the branch
#      <2> a_group_frequency: The array of frequencies
#  Preconditon(s):
#      <1> a_group_frequency != NULL
#      <2> a_group_frequency[ROOM_GROUP_COUNT] > 0
#  Returns: The array index corresponding to the chosen room
#           group.  This is a value weighted to the upper end
#           of the range [0, ROOM_GROUP_COUNT).  The weighting
#           is stronger at lower depths.
#  Side Effect: N/A
#

{{
function getRandomGroupCorner (depth, a_group_frequency)
  assert(a_group_frequency ~= nil,
         "a_group_frequency cannot == nil")
  assert(a_group_frequency.total > 0,
         "total frequency must be > 0")

  local depth_fraction = getDepthFraction(depth)
  local trials = 4 - math.floor(depth_fraction * 4)

  local largest_group = 0
  for i = 0, trials - 1 do
    local group = getRandomGroup(a_group_frequency)
    if group > largest_group then
      largest_group = group
    end
  end

  return largest_group
end
}}



########
#  Information on Room Connections
#
#  There are two things that could be refered to as room
#    connections.  They are:
#      -> How a room is connected to the rest of the level.
#         These are refered to as connections.
#      -> How and where the doors to a room are placed.  These
#         are refered to as door types.
#
#  To change the frequency of connection types, modify the
#    values set in the setConnectionFrequency function.  Note
#    that any difficulty with setting up a connection causes
#    the room to revert to CONNECTION_NORMAL.  This happens to
#    most connections calculated.  Also note that all rooms
#    with connection type CONNECTION_NONE will eventually be
#    converted to connection type CONNECTION_NORMAL if they do
#    not have stairs placed in them.  Finally, note that if
#    CONNECTION_BEFORE and CONNECTION_AFTER do not have the
#    same frequency, the map may appear unbalanced.
#
#  There are 4 types of connections:
#      -> CONNECTION_NORMAL: The room is connected to the
#                            hallways.
#      -> CONNECTION_NONE: The room is not connected to the
#                          rest of the map.  If such a room does
#                          not contain a stairs, it will be
#                          eventually converted to connection
#                          type CONNECTION_NONE.
#      -> CONNECTION_BEFORE
#      -> CONNECTION_AFTER: The room is connected to the room
#                           before/after it in a line.  Two
#                           constants are needed to determine
#                           which side to generate the door on.
#
#  CONNECTION_COUNT is the number of connection types.
#
#  These only govern what a room connects to, not what is
#    connected to it.  For example, assume there are two rooms
#    with a door between them, but no connection to the rest of
#    the level.  One of these rooms case no connection, and the
#    other room is connected to the first.
#
#  Connections for the maze and grid layouts are handled using a
#    different system.
#
#
#  getConnectionFrequencyArray
#
#  Purpose: To create the table of connection type frequencies.
#  Parameter(s): N/A
#  Preconditon(s): N/A
#  Returns: The array of the frequencies of thge connection
#          types.  No frequency is negative.  The total is at
#          least 1.
#  Side Effect: N/A
#
#  getRandomConnectionType
#
#  Purpose: To choose a random connection type for a room.
#  Parameter(s): N/A
#  Preconditon(s): N/A
#  Returns: The connection type for the room.  This is a
#           value in the range [0, CONNECTION_COUNT).
#  Side Effect: N/A
#

{{
CONNECTION_COUNT  = 4
CONNECTION_NORMAL = 0
CONNECTION_NONE   = 1
CONNECTION_BEFORE = 2
CONNECTION_AFTER  = 3

function getRandomConnectionType ()
  local A_CONNECTION_FREQUENCY =
  { [0]=2, 3, 3, 1 }

  local total = 0
  for i = 0, CONNECTION_COUNT - 1 do
    total = total + A_CONNECTION_FREQUENCY[i]
  end

  local chosen = crawl.random2(total)
  for i = 0, CONNECTION_COUNT - 1 do
    chosen = chosen - A_CONNECTION_FREQUENCY[i]
    if chosen < 0 then
      return i
    end
  end

  return CONNECTION_COUNT - 1
end
}}

#
#  Door types determine how a door to a room is placed.  Each
#    door type corresponds to a differant type of subvault.
#
#  To change the frequency of door types, it is probably
#    sufficient to change the values in the A_DOOR_TYPE_FREQUENCY array
#    in the getRandomDoorType function.  If a more complex
#    system of assigning door types is desired, the function
#    logic can also be changed.  Note that most rooms in the
#    maze and grid layouts are assigned to DOOR_TYPE_SPIN
#    directly, and are thus unaffected by this function.
#
#  The four door types are as follows:
#      -> DOOR_TYPE_SPIN: The door is not part of the subvault.
#                         The subvault has no defined
#                         orientation and can have doors on all
#                         four sides.
#      -> DOOR_TYPE_FACING: The subvault has a front and
#                           includes a door on that side.  Other
#                           rooms may be connected to this room
#                           on the other three sides.
#      -> DOOR_TYPE_DEAD_END: The subvault has a front and
#                             includes a door on that side.  No
#                             other room may be connected to
#                             this one.
#      -> DOOR_TYPE_CITY: The subvault includes the walls of the
#                         room.  This door type is only used for
#                         the city and chaotic city layouts,
#                         where rooms never connect.  However,
#                         other door types are also used for
#                         these layouts.
#
#  DOOR_TYPE_COUNT is the number of door types.
#
#  The chance of a corner or city room with a door type of
#    DOOR_TYPE_SPIN or DOOR_TYPE_FACING having a side door is
#    determined by the CORNER_ROOM_SIDE_DOOR_PERCENT and
#    CITY_ROOM_SIDE_DOOR_PERCENT constants.  Note that the
#    CITY_ROOM_SIDE_DOOR_PERCENT constant is applied 3 times,
#    once to each side of the room that does not have the main
#    door.
#
#  A_DOOR_TYPE_NAME is the array the contains the strings for
#    the door types.  These strings are used as part of the
#    subvault tags.  I can't think of a good reason why they
#    would need to be changed.
#
#
#  getRandomDoorType
#
#  Purpose: To determine the door type for a room.  This
#           controls how the room can be connected to other
#           rooms without messing up the subvaults.
#  Parameter(s):
#      <1> allow_dead_end: Whether this room can have door
#                          type DOOR_TYPE_DEAD_END
#      <2> allow_city: Whether this room cann have door type
#                      DOOR_TYPE_CITY
#  Preconditon(s): N/A
#  Returns: The door type for the room.
#  Side Effect: N/A
#
#

{{
DOOR_TYPE_COUNT    = 4
DOOR_TYPE_SPIN     = 0
DOOR_TYPE_FACING   = 1
DOOR_TYPE_DEAD_END = 2
DOOR_TYPE_CITY     = 3

A_DOOR_TYPE_NAME = { [0]="spin", "facing", "dead_end", "city" }

CORNER_ROOM_SIDE_DOOR_PERCENT = 10
CITY_ROOM_SIDE_DOOR_PERCENT   = 5

function getRandomDoorType (allow_dead_end, allow_city)

  local A_DOOR_TYPE_FREQUENCY = { [0]=2, 3, 4, 5 }

  local total_frequency = 0
  for i = 0, DOOR_TYPE_COUNT - 1 do
    -- skip invalid choices - I wish for "continue"
    if (i ~= DOOR_TYPE_DEAD_END or allow_dead_end ) and
       (i ~= DOOR_TYPE_CITY     or allow_city     ) then
      total_frequency = total_frequency + A_DOOR_TYPE_FREQUENCY[i]
    end
  end

  local chosen = math.floor(crawl.random2(total_frequency))

  for i = 0, DOOR_TYPE_COUNT - 1 do
    -- skip invalid choices
    if (i ~= DOOR_TYPE_DEAD_END or allow_dead_end ) and
       (i ~= DOOR_TYPE_CITY     or allow_city     ) then
      chosen = chosen - A_DOOR_TYPE_FREQUENCY[i]
      if chosen < 0 then
        return i
      end
    end
  end

  assert(false, "Invalid door type selected")
  return DOOR_TYPE_SPIN
end
}}



########
#  Information on Room Orientation
#
#  A room can be oriented in several ways.  These are refered to
#    as the facing value for the room.  These are:
#      -> It can connect along one of the 4 cardinal direction
#      -> It can be on a corner, connecting on 2 sides
#      -> It can be a city room and connect on all four sides
#      -> It can be disconnected from the main level
#
#  There can also be other rooms connected to a room.  However,
#    these connections are stored with the room that is
#    attached on, not with the room it is connected to.  For
#    example, in the diagram below, room A is attached to the
#    hallway, room B is attached to room A, room C is not
#    attached, and room D, a corner room, is attached twice.
#
#     AAA BBB CCC DDD ..
#     AAA+BBB CCC DDD+..
#     AAA BBB CCC DDD ..
#          +       +  ..
#  .....................
#  .....................
#
#
#  FACING_COUNT is the number of facing values a room
#    may have.
#
#  FACING_VALID_COUNT is the number of facing values that
#    can be used to generate rooms.  It does not include
#    placeholder values such as FACING_UNASSIGNED.
#
#  FACING_DIRECTION_COUNT is the number of facing values that
#    indicate actual directions.  This does not include
#    placeholder values, such as FACING_UNASSIGNED, or special
#    cases, such as FACING_CITY.
#
#  FACING_X_MINUS, FACING_X_PLUS, FACING_Y_MINUS, and
#    FACING_Y_PLUS are constants representing that a room is
#    facing in the negative/positive x/y direction.  Such a room
#    has a single door.
#
#  FACING_CORNER_XM_YM, FACING_CORNER_XM_YP,
#    FACING_CORNER_XP_YM, and FACING_CORNER_XP_YP are constants
#    representing that a room is a corner with possible
#    entrances on two sides.  Such a room may have 1 or 2 doors.
#
#  FACING_CITY is a constant representing that a room is not
#    facing in a direction because it borders the map on all
#    sides.
#
#  FACING_NONE is a constant representing that a room is not
#    facing in a direction because it has no door.  This is to
#    be used for rooms for rooms with CONNECTION_NONE,
#    CONTENT_SOLID, and CONTENT_EXTRA_WALL.
#
#  FACING_UNASSIGNED is a constant representing that the facing
#    direction for a room is not yet known.  This constant
#    cannot be used to create rooms.
#

{{
local FACING_COUNT           = 11
local FACING_VALID_COUNT     = 10
local FACING_DIRECTION_COUNT = 4

local FACING_X_MINUS = 0
local FACING_X_PLUS  = 1
local FACING_Y_MINUS = 2
local FACING_Y_PLUS  = 3

local FACING_CORNER_XM_YM = 4
local FACING_CORNER_XM_YP = 5
local FACING_CORNER_XP_YM = 6
local FACING_CORNER_XP_YP = 7

local FACING_CITY = 8
local FACING_NONE = 9

local FACING_UNASSIGNED = 10
}}



########
#  Information on Room Contents
#
#  The are two kinds of room content types that could be added.
#
#  <|>
#  To add a room content type to be selected based on
#    probability (e.g. CONTENT_STATUES or CONTENT_ZOT_TRAPS):
#      <1> Add an appropriate constant before CONTENT_VANISH.
#          Increase the numbers on all the suceeding content
#          types. The order DOES matter in some cases.
#      <2> Update the CONTENT_COUNT, CONTENT_VALID_COUNT, and
#          CONTENT_PROBABILITY_COUNT constants.
#      <3> Add a new name to A_CONTENT_NAME.
#      <4> Add a new line in setContentFrequency
#      <5> Make the appropriate subvaults for each size group
#          for door type DOOR_TYPE_SPIN and other door types
#          if desired
#
#  <|>
#  To add a room content type for a branch or portal entry:
#      <1> Add an appropriate constant before the serial vault
#          constants.  Increase the numbers on all the portal
#          vault constants.
#      <2> Update the CONTENT_COUNT and CONTENT_VALID_COUNT
#          constants.
#      <3> Add a new name to A_CONTENT_NAME.
#      <4> Add code in the getEntries function to chose when to
#          generate the new branch/portal entry
#      <6> Make the appropriate subvaults for each size group
#          for door type DOOR_TYPE_SPIN and other door types
#          if desired
#
#  <|>
#  To add a room content type for a serial vault:
#      <1> Add an appropriate constant immediately before
#          CONTENT_UNASSIGNED.
#      <2> Update the CONTENT_COUNT and CONTENT_VALID_COUNT
#          constants.
#      <3> Add a new name to A_CONTENT_NAME.
#      <4> Add code in the calculateContentSerialVault function
#          to chose when to generate the new serial vault
#      <6> Make the appropriate subvaults for each relevant
#          size group for door type DOOR_TYPE_SPIN and other
#          door types if desired
#
#  If your new room content type is goinf to be placed
#    frequenctly, consider also making rooms with any or all of
#    door type DOOR_TYPE_FACING, DOOR_TYPE_DEAD_END, and
#    DOOR_TYPE_CITY.  These rooms will be selected by the map
#    generator if they exist.  Note that the level generator
#    only uses a simple exists/does not exist check.  If you
#    make a single room with DOOR_TYPE_FACING and many with
#    DOOR_TYPE_SPIN, the facing door type will still be used for
#    a significant fraction of the total rooms, and they will
#    all be place the same subvault.
#
#
#  The contents of a rooms indicate what sort of thing is in it.
#    For detailed descriptions, see at the top of the file.
#    Once the rooms have been generated, the content types are
#    assigned as follows:
#      <1> All rooms are set to CONTENT_UNASSIGNED.
#      <2> Stairs are added to rooms.  There may be 3 stairs in
#          one room, 1 one stairs added to each of three rooms.
#      <3> Special rooms such as branch entrances are added.
#      <4> Some fraction of the remaining rooms are filled solid
#          with walls.  No rooms are disconnected.
#      <5> The remaining rooms are filled by probablities.
#          These typically contain features, monsters, or loot.
#
#  CONTENT_COUNT is the total number of room content types.
#
#  CONTENT_VALID_COUNT is the number of room content types that
#    can be used to generate rooms.  This does not include
#    placeholder values such as CONTENT_UNASSIGNED.
#
#  CONTENT_PROBABILITY_COUNT is the number of room content types
#    that are assigned randomly by probabilities.
#
#  CONTENT_EMPTY, CONTENT_ENCOUNTER, CONTENT_DANGEROUS,
#    CONTENT_LOOT, CONTENT_VANISH, and CONTENT_HALLWAY are
#    constants representing the room content types that are
#    selected by probabilities.  The first four of these are
#    used with all layouts.  CONTENT_VANISH is only used for
#    the city (not including chaotic city) layout, and indicates
#    that a room should not be generated (not even the walls).
#    CONTENT_HALLWAY is only used for the maze (not including
#    grid) layout and indicates that a halklway should be
#    generated instead of a room.
#
#  CONTENT_SOLID is a constant indicating that a room should be
#    filled solid with the wall material.
#
#  CONTENT_STAIRS_UP_3 and CONTENT_STAIRS_DOWN_3 are constants
#    representing that a room contains all three staircases.
#    These constants denote all three up staircases and all
#    three down staircases respectively.  These rooms are
#    guarenteed to be connected to the main part of the level.
#
#  CONTENT_STAIRS_UP_1A, CONTENT_STAIRS_DOWN_1A,
#    CONTENT_STAIRS_UP_1B, CONTENT_STAIRS_DOWN_1B,
#    CONTENT_STAIRS_UP_1C, and CONTENT_STAIRS_DOWN_1C are
#    constants indicating that a rooms contains the specified
#    stairs.  All rooms containg up stairs and the room
#    containing the CONTENT_STAIRS_DOWN_1A stairs are guarenteed
#    to be connected to main part of the level and thus to each
#    other.  The CONTENT_STAIRS_DOWN_1B and
#    CONTENT_STAIRS_DOWN_1C rooms may be disconnected from the
#    main part of the level, often in a single, inaccessible
#    room.
#
#  CONTENT_BRANCH_CRYPT and CONTENT_BRANCH_BLADE are constants
#    representing that a room contains the entry to the
#    indicated branch or portal vault.  Each branch or portal
#    vault requires its own content type.  This is so that
#    content types can be added when the appropriate subvaults
#    have been made.
#
#  Content types for the entrances to portal vaults are:
#    -> CONTENT_PORTAL_BAZAAR
#    -> CONTENT_PORTAL_ICE_CAVE
#    -> CONTENT_PORTAL_LABYRINTH
#    -> CONTENT_PORTAL_TROVE
#    -> CONTENT_PORTAL_WIZARD_LAB
#    -> CONTENT_PORTAL_ZIGGURAT
#
#  Content types for serial vaults are:
#    -> CONTENT_SERIAL_MINIWIZLABS
#    -> CONTENT_SERIAL_CRYSTAL
#    -> CONTENT_SERIAL_MAGIC_RESEARCH
#
#  If you are adding a new content type (e.g. for a new portal
#    vault), add it here (immediately before
#    CONTENT_UNASSIGNED).
#
#  CONTENT_UNASSIGNED is a constant representing that the
#    content for a room has not been chosen yet.
#

{{
CONTENT_COUNT             = 27
CONTENT_VALID_COUNT       = 26
CONTENT_PROBABILITY_COUNT = 6

CONTENT_EMPTY                  = 0
CONTENT_ENCOUNTER              = 1
CONTENT_DANGEROUS              = 2
CONTENT_LOOT                   = 3

CONTENT_VANISH                 = 4
CONTENT_HALLWAY                = 5

CONTENT_SOLID                  = 6

CONTENT_STAIRS_UP_3            = 7
CONTENT_STAIRS_DOWN_3          = 8

CONTENT_STAIRS_UP_1A           = 9
CONTENT_STAIRS_DOWN_1A         = 10
CONTENT_STAIRS_UP_1B           = 11
CONTENT_STAIRS_DOWN_1B         = 12
CONTENT_STAIRS_UP_1C           = 13
CONTENT_STAIRS_DOWN_1C         = 14

CONTENT_BRANCH_CRYPT           = 15
CONTENT_BRANCH_BLADE           = 16

CONTENT_PORTAL_BAZAAR          = 17
CONTENT_PORTAL_ICE_CAVE        = 18
CONTENT_PORTAL_LABYRINTH       = 19
CONTENT_PORTAL_TROVE           = 20
CONTENT_PORTAL_WIZARD_LAB      = 21
CONTENT_PORTAL_ZIGGURAT        = 22

-- CONTENT_SERIAL_MINIWIZLAB      = 23
CONTENT_SERIAL_CRYSTAL         = 24
CONTENT_SERIAL_MAGIC_RESEARCH  = 25

CONTENT_UNASSIGNED             = 26
}}

#
#  A_CONTENT_NAME is a constant array containg the names of the
#    content types.  These will form part of the tag for the
#    subvault used to fill a room.  Content types with the same
#    name use the same subvaults.  A subvault might also be
#    marked with more than one tag.  The content types that do
#    not generate subvaults all have the name "ERROR".
#
#  A room containing a single down stairs and connection type
#    CONNECTION_NONE will use CONTENT_NAME_SECRET as its
#    content type.  These are "secret" rooms that are only
#    accessible from the floor below.  And teleport, I guess.
#

{{
A_CONTENT_NAME =
  { [0]="empty",
        "encounter",
        "dangerous",
        "loot",
        "ERROR",
        "ERROR",
        "ERROR",
        "up3",
        "down3",
        "up1",
        "down1",
        "up1",
        "down1",
        "up1",
        "down1",
        "crypt",
        "blade",
        "bazaar",
        "icecave",
        "lab",
        "trove",
        "wizlab",
        "ziggurat",
        "ERROR",
        "crystal",
        "magic_research",
        "ERROR" }
CONTENT_NAME_SECRET = "secret"
}}

#
#  getContentFrequencyArray
#
#  Purpose: To generate the table of room content type
#          frequencies.  This only includes room content types
#          that are placed by probability, such as
#          CONTENT_EMPTY.  It does not include solid rooms or
#          content types that a specific number of are placed,
#          such as stairs.
#  Parameter(s): N/A
#  Preconditon(s): N/A
#  Returns: The array containing the frequencies of the room
#          content types.  No frequency is negative.  The total
#          frequency is at least 1.
#  Side Effect: N/A
#

{{
function getContentFrequencyArray ()

  local a_content_frequency = {}

  a_content_frequency[CONTENT_EMPTY]      = 10
  a_content_frequency[CONTENT_ENCOUNTER]  = 5
  a_content_frequency[CONTENT_DANGEROUS]  = 2
  a_content_frequency[CONTENT_LOOT]       = 1
  a_content_frequency[CONTENT_VANISH]     = 0
  a_content_frequency[CONTENT_HALLWAY]    = 0
  -- the Crawl wiki suggests: 3 6 4 2 0 0

  return a_content_frequency
end
}}

#
#  CONTENT_VANISH_FREQUENCY_CITY is a constant representing the
#    frequency of rooms with content type CONTENT_VANISH on
#    the city layout.  These rooms are not added, leaving holes
#    in the grid.
#
#  A_CONTENT_HALLWAY_FREQUENCY_MAZE is a constant array containg
#    the frequency of rooms with content type CONTENT_HALLWAY on
#    the maze level.  The frequency is stored for each size of
#    room.  Hallways should be more frequent for smaller rooms
#    for two reasons:
#      <1> hallways are effectively wasted space, and there may
#          be little space to waste with large rooms
#      <2> hallways are the width of the area reserved for the
#          room door, and really wide hallways look kind of bad
#

{{
CONTENT_VANISH_FREQUENCY_CITY = 5
A_CONTENT_HALLWAY_FREQUENCY_MAZE =
  { [0]=100, 60, 24, 16, 8 }
}}

#
#  CONTENT_PROBABILITY_MAX_VARIATION
#
#  How many fewer rooms of a given content type may be selected
#    before the content selection algorithm forces a room to
#    have the underselected content type.  This value must be
#    strictly greater than 0.0 to avoid a crash when selecting
#    the content type for the first room.
#

{{
CONTENT_PROBABILITY_MAX_VARIATION = 0.5
}}

#
#  CONTENT_SOLID_FREQUENCY_CROSS
#  CONTENT_SOLID_FREQUENCY_SQUARE_RING
#  CONTENT_SOLID_FREQUENCY_SQUARE_RING_CHAOTIC_CITY
#  CONTENT_SOLID_FREQUENCY_SQUARE_RING_HUGE_CENTER
#  CONTENT_SOLID_FREQUENCY_CITY
#  CONTENT_SOLID_FREQUENCY_CHAOTIC_CITY
#
#  These conatasnts represent the frequency of rooms with
#    content type CONTENT_SOLID on the indicated layout.  The
#    goal is to make the number of rooms comparable between
#    layouts.
#
#  A_CONTENT_SOLID_FREQUENCY_MAZE and
#    A_CONTENT_SOLID_FREQUENCY_GRID are constant arrays
#    containing the frequency of rooms with content type
#    CONTENT_SOLID on the maze/grid layout.  There are seperate
#    values for each size of room for each size of room.  Note
#    that rooms can only be mades solid if there is not another
#    room attached to them, so more solid rooms makes the map
#    less "branchy".  The goal is to make the number of rooms
#    comparable to other layouts.
#
#
#  getContentSolidFrequencyWalkways
#
#  Purpose: To determine the frequency of rooms with content
#          type CONTENT_SOLID for a walkways layout with the
#          specified room group frequencies.
#  Parameter(s):
#      <1> a_group_frequency: The array containing the
#                             frequency of each room group
#      <2> a_group_frequency[ROOM_GROUP_TOTAL_FREQUENCY] > 0
#  Preconditon(s):
#      <1> a_group_frequency != NULL
#  Returns: The frequency of CONTENT_SOLID rooms.
#  Side Effect: N/A
#

{{
CONTENT_SOLID_FREQUENCY_SQUARE_RING                = 12
CONTENT_SOLID_FREQUENCY_CROSS                        = 8
CONTENT_SOLID_FREQUENCY_SQUARE_RING_CHAOTIC_CITY= 6
CONTENT_SOLID_FREQUENCY_SQUARE_RING_HUGE_CENTER = 6
CONTENT_SOLID_FREQUENCY_CITY                        = 12
CONTENT_SOLID_FREQUENCY_CHAOTIC_CITY                = 4

A_CONTENT_SOLID_FREQUENCY_MAZE =
  { [0]=4, 4, 4, 0, 0 }
A_CONTENT_SOLID_FREQUENCY_GRID =
  { [0]=12, 8, 6, 4, 2 }

function getContentSolidFrequencyWalkways (a_group_frequency)
  assert(a_group_frequency ~= nil,
         "a_group_frequency cannot == nil")
  assert(a_group_frequency.total > 0,
         "total frequency must be > 0")

  local A_SOLID_FREQUENCY =
  { [0]=40, 20, 12, 8, 4 }

  -- calculate the weighted average
  local total_solid = 0
  local total_group = 0
  for i = 0, ROOM_GROUP_COUNT - 1 do
    local group_frequency = a_group_frequency[i]
    total_group = total_group + group_frequency
    total_solid = total_solid +
                  group_frequency * A_SOLID_FREQUENCY[i]
  end

  return math.floor(total_solid / total_group)
end
}}

#
#  isStairsTogetherUp
#  isStairsTogetherDown
#
#  Purpose: To determine whether the stairs up/down for a map at
#           the specified depth are together.
#  Parameter(s):
#      <1> depth: The depth of the map within the branch
#  Preconditon(s): N/A
#  Returns: Whether the stairs up/down should be generated in
#           the same room.
#  Side Effect: N/A
#

{{
function isStairsTogetherUp (depth)
  local depth_fraction = getDepthFraction(depth)
  local stairs_together_percent = 10 + depth_fraction * 40

  -- always together on top floor
  local random_value = crawl.random2(100)
  if random_value < stairs_together_percent or depth <= 1 then
    return true
  else
    return false
  end
end

function isStairsTogetherDown (depth)
  local depth_fraction = getDepthFraction(depth)
  local stairs_together_percent = 10 + depth_fraction * 40

  -- always together directly above bottom floor
  local random_value = crawl.random2(100)
  if random_value < stairs_together_percent or
     depth >= dgn.br_depth("Vaults") - 1 then
    return true
  else
    return false
  end
end
}}

#
#  getEntries
#
#  Purpose: To determine the branch and portal entries to add
#           for this map.
#  Parameter(s):
#      <1> depth: The depth of the map within the branch
#  Preconditon(s): N/A
#  Returns: The branch entries to generate for this map.
#  Side Effect: N/A
#

{{
function getEntries (depth)
  local a_entries = {}
  a_entries.count = 0

  --
  --  branch entries
  --

  -- add the entry to the Crypt
  if you.where() == dgn.level_name(dgn.br_entrance("Crypt")) then
    a_entries[a_entries.count] = CONTENT_BRANCH_CRYPT
    a_entries.count = a_entries.count + 1
  end

  -- add the entry to the Hall of Blades
  if you.where() == dgn.level_name(dgn.br_entrance("Blade")) then
    a_entries[a_entries.count] = CONTENT_BRANCH_BLADE
    a_entries.count = a_entries.count + 1
  end

  --
  --  If there are ever more branches conected to the vaults,
  --    add the entries here.  Branch entries should be added
  --    based on where the player is.
  --
  --  Don't forget to increase the count element of a_entries!
  --

  --
  -- portal vault entries
  --
  --  dgn.map_by_tag("BAR") returns true if a room with tag BAR
  --    is available to add to the map.  A map without allow_dup
  --    that has already been placed will return false.
  --

  -- add an entry to a bazaar (1%) - multiple allowed
  if crawl.one_chance_in(100) then
    a_entries[a_entries.count] = CONTENT_PORTAL_BAZAAR
    a_entries.count = a_entries.count + 1
  end

  -- add the entry to the ice cave (5%)
  if dgn.map_by_tag("uniq_ice_cave") and crawl.one_chance_in(20) then
    a_entries[a_entries.count] = CONTENT_PORTAL_ICE_CAVE
    a_entries.count = a_entries.count + 1
  end

  -- add the entry to the labyrinth (5%)
  if dgn.map_by_tag("uniq_lab") and crawl.one_chance_in(20) then
    a_entries[a_entries.count] = CONTENT_PORTAL_LABYRINTH
    a_entries.count = a_entries.count + 1
  end

  -- add the entry to the treasure trove (5%)
  if dgn.map_by_tag("uniq_trove") and crawl.one_chance_in(20) then
    a_entries[a_entries.count] = CONTENT_PORTAL_TROVE
    a_entries.count = a_entries.count + 1
  end

  -- add the entry to the wizard lab (5%)
  if dgn.map_by_tag("uniq_wizlab") and crawl.one_chance_in(20) then
    a_entries[a_entries.count] = CONTENT_PORTAL_WIZARD_LAB
    a_entries.count = a_entries.count + 1
  end

  -- no ziggurats in Vaults

  --
  --  If you want to add more entries, add the constants onto
  --    the array here.  Portal vault entries should probably be
  --    added based on a percent chance.
  --
  --  Don't forget to increase the count element of a_entries!
  --

  return a_entries
end
}}



########
#  Miscellaneous Information on Rooms
#
#  These parameters specifically affect rooms in various ways.
#
#
#  CORNER_ROOM_SIDE_DOOR_PERCENT is the chance of a corner room
#    having a second door on its other accessible side.  There
#    is only this chance if the subvault containing the room
#    contents is not a dead end subvault.  If it is a dead end
#    subvault, there is never a side door.
#
#  CITY_ROOM_SIDE_DOOR_PERCENT is the chance of a room on a
#    city layout (including chaotic city) having an extra door
#    on any given side.  One door is guarenteed (except for
#    stairs-access-only rooms).  There is only this chance if
#    the subvault containing the room contents is not a dead
#    end subvault.
#

{{
CORNER_ROOM_SIDE_DOOR_PERCENT        = 10
CITY_ROOM_SIDE_DOOR_PERCENT        = 5
}}

#
#  CHAOTIC_CITY_MINIMUM_ROOMS_PLACED is the minimum number of
#    rooms to place on a chaotic city layout.  This does not
#    include the square ring chaotic city layout.  If the layout
#    generator cannot place enough rooms of the intended size,
#    closets will be added to uincrease the total to this
#    number.
#
#  CHAOTIC_CITY_PLACE_ATTEMPTS_FACTOR is a factor used to
#    calculate how many attempts to make to place a room for a
#    chaotic city.  A larger number means more attempts are
#    made.  Increasing this value may yeild a more dense city,
#    but will make the map generate more slowly.
#
#  This value is applied as a scaling factor to the total area
#   of the city, so increasing this value above 1.0 will not
#   affect the city generated.  It will, however, continue to
#   make the layout generation slower.
#

{{
local CHAOTIC_CITY_MINIMUM_ROOMS_PLACED = 8
local CHAOTIC_CITY_PLACE_ATTEMPTS_FACTOR = 0.05
}}

#
#  BRANCH_FACTOR_GRID
#  BRANCH_FACTOR_MAZE
#
#  A factor used to determine how likely the grid layout is to
#    branch.  A higher factor makes the layout branch more.
#    This values is used as a percentage internally, so it must
#    lie in the range [0, 100].  This does not simply represent
#    the chance of a branch a point.
#

{{
BRANCH_FACTOR_GRID = 70
BRANCH_FACTOR_MAZE = 30
}}

#
#  EXTRA_CONNECTION_PERCENT_GRID
#  EXTRA_CONNECTION_PERCENT_MAZE
#
#  The percentage chance of connecting two agjacent cells in
#    the grid layout.  There is only this chance of connection
#    if the grid cells were arlready adjacent and both
#    non-hallway rooms using door type DOOR_TYPE_SPIN.  This
#    value should lie in the range [0, 100].
#

{{
EXTRA_CONNECTION_PERCENT_GRID = 50
EXTRA_CONNECTION_PERCENT_MAZE = 0
}}

#
#  STAIRS_DISCONNECTED_PERCENT
#
#  The percentage chance that the second/third stairs will be
#    in a room disconnected from the main part of the level.
#    If the three down stairs are placed seperately, this
#    chance is applied for each stairs.  Otherwise, the stairs
#    are always connected.
#

{{
STAIRS_DISCONNECTED_PERCENT = 75
}}



########
#  Miscellaneous Constants
#
#  These constants and functions don't fit well anywhere else.
#    Changing them will almost certainly break layouts.
#
#
#  NO_ROOM is a constant indicating that there is no room off
#    the specified end of the line of rooms.  This is used
#    calculating how a line of rooms are connected.
#

{{
NO_ROOM = 1.0e20
}}

#
#  SQUARE_RING_ROOM_LINE_COUNT is a constant representing the
#    number of lines of rooms for the the square ring layout.
#    There are 4 lines on the outside of the square and 4 on
#    the inside.  The lines of rooms are numbered as follows:
#
#     2----->
#  0 +-------+ 1
#  | |*6--->*| |
#  | |4     5| |
#  | |v     v| |
#  | |*7--->*| |
#  v +-------+ v
#     3----->
#
#
#  CROSS_BRANCH_COUNT is a constant representing the number of
#    branches of rooms for the cross layout.  There is one
#    branch for each side of the hallway for each arm.  The
#    branches are numbered as follows:
#
#    1 | 5
#  0 * | * 4
#  ----+----
#  2 * | * 6
#    3 | 7
#
#
#  WALKWAYS_CORNERS_PER_BRANCH is a constant representing the
#    number of corners added for each branch in the walkways
#    layout.  There is one corner on each side of the branch
#    above the central hallway and one on each side of the
#    branch below the central hallway.  The branches are
#    numbered as follows:
#
#    |
#   0|2
#  --+--
#   1|3
#    |
#

{{
SQUARE_RING_ROOM_LINE_COUNT        = 8
CROSS_BRANCH_COUNT                 = 8
WALKWAYS_CORNERS_PER_BRANCH        = 4
}}





################################################################################
#  Other Supporting Functions
#
#  These functions are called as part of generating layouts.
#    Many of these are called by several layouts, although some
#    are more specific.
#



########
#
#  General Room Stuff
#
#  This a standard table (struct in C++) containing information
#    about a single room.  It is used to store information about
#    a room by all the layouts.  Many of these fields store the
#    constants defined above.  The fields are all prefaced by m_
#    because they are all member variables in C++.
#
#  The fields used by all (or most) layouts are:
#      -> group: The size group for the room
#      -> connection: The connection type
#          -> This indicates how this room connects to the rest
#             of the map
#      -> connected_to: The room this room is attached to
#          -> If this room is attached to the main part of the
#             level directly, this field has a value of NO_ROOM
#      -> attached_count: The number of rooms attached to this
#                         room
#      -> content: The content type for the room
#
#  The special-purpose fields are:
#      -> is_dummy_wall: If this is true, this room is a
#                        placeholder for an extra 1-glyph-thick
#                        wall instead of a room
#          -> This is used by the square ring and the square
#             ring huge center layouts
#          -> If this is true, the room group is always
#             ROOM_GROUP_CLOSET
#      -> x
#      -> y: The position of the room
#          -> This is used by the chaotic city and the square
#             ring chaotic city layouts
#          -> This is the minimum x/y coordinate of the room
#             proper and does not include the walls of the room
#
#      -> facing_direction: The direction of the door for the room
#          -> This is used by the maze and grid layouts
#
#
#  createDefaultRoom
#
#  Purpose: To create a room with the specified group.
#  Parameter(s):
#      <1> group: The size group for the room
#  Preconditon(s):
#      <1> group < ROOM_GROUP_COUNT
#  Returns: A room with default values.  This room has group
#           group, connection type CONNECTION_NORMAL, is not
#           connected to any other rooms, and has content type
#           CONTENT_UNASSIGNED.
#  Side Effect: N/A
#

{{
function createDefaultRoom (group)
  assert(group >= 0, "invalid room size group: " .. group)
  assert(group < ROOM_GROUP_COUNT,
         "invalid room size group: " .. group)

  local room = {}

  room.m_group = group
  room.m_connection = CONNECTION_NORMAL
  room.m_connected_to = NO_ROOM
  room.m_attached_count = 0
  room.m_content = CONTENT_UNASSIGNED
  room.m_is_dummy_wall = false
  room.m_x = 0
  room.m_y = 0
  room.m_facing_direction = FACING_UNASSIGNED

  return room
end
}}



########
#
#  Functions for Placing and Connecting Rooms
#
#  These functions place rooms and control how they are
#    connected.  They are grouped together becuase the two tasks
#    are interconnected and often performed simultaneously,
#
#
#  calculateRoomsForLine
#
#  Purpose: To calculate the number of each group of room to
#           place for in a line. This does not include special
#           cases, such as corner rooms for the square ring
#           layout.  Rooms are added until the specified
#           minimum value is reached, or until adding another
#           rooms would make the total size greater than the
#           specified maximum value.
#  Parameter(s):
#      <1> min_size: The minimum total size for the rooms
#      <2> max_size: The maximum total size for the rooms
#      <3> a_group_frequency: The frequencies of the room
#                             groups
#      <4> max_group: The largest room group to be considered
#      <5> a_count_group: The array to fill with the number of
#                         rooms from each group
#      <6> force_largest: Whether to ensure that a room of the
#                         largets group is added
#  Preconditon(s):
#      <1> min_size >= 0
#      <2> min_size <= max_size
#      <3> a_group_frequency != NULL
#      <4> a_group_frequency[ROOM_GROUP_TOTAL_FREQUENCY] >= 1
#      <5> max_group < ROOM_GROUP_COUNT
#      <6> a_group_frequency[max_group] >= 1
#      <7> a_count_group != NULL
#  Returns: The total size of all the rooms, including one wall
#           for each room.
#  Side Effect: a_count_group is set to contain the number of
#               each room group.  No rooms larger than
#               max_group are selected.  If force_largest is
#               equal to true, at least one room of group
#               max_group is guarenteed to be chosen.
#

{{
function calculateRoomsForLine (min_size,
                                max_size,
                                a_group_frequency,
                                max_group,
                                a_count_group,
                                force_largest)
  assert(min_size >= 0, "min_size must be at least 0")
  assert(min_size <= max_size, "min_size cannot be greater than max_size")
  assert(max_group < ROOM_GROUP_COUNT)
  assert(a_group_frequency ~= nil,
         "a_group_frequency cannot == nil")
  assert(a_group_frequency.total > 0,
         "total frequency must be > 0")
  assert(a_group_frequency[max_group] >= 1,
         "rooms of the maximum group size must be permitted")
  assert(a_count_group ~= nil, "a_count_group cannot be nil")

  --
  --  Rooms are added until the minimum total size is
  --    reached, or until adding a room would make the
  --    total size of the rooms larger than the maximum.
  --

  for i = 0, ROOM_GROUP_COUNT - 1 do
    a_count_group[i] = 0
  end

  local total_size = 0
  -- loop breaks below
  while true do
    local room_group

    if total_size == 0 and force_largest then
      room_group = max_group
    else
      room_group = getRandomGroup(a_group_frequency)
    end

    -- don't allow rooms bigger than the maximum
    if room_group <= max_group then

      -- room_size includes wall cell
      local room_size = A_ROOM_SIZE[room_group] + 1

      if total_size + room_size >= max_size then
        -- end the loop when the next room does not fit.
        break
      else
        a_count_group[room_group] = a_count_group[room_group] + 1
        total_size = total_size + room_size

        if total_size >= min_size then
          -- end the loop when we rech the minimum size
          break
        end
      end
    end
  end

  return total_size
end
}}

#
#  calculateRoomsForChaoticCity
#
#  Purpose: To fill the specified array with the rooms to place
#           in a chaotic city.  The size group and position are
#           calculated for the rooms.  Between the specified
#           minimum and maximum number of rooms are placed in
#           the specified area.  If not enough rooms of the
#           specified size groups fit in the area, enough
#           closets (1x1 rooms) will be added to reach the
#           minimum number of rooms.
#  Parameter(s):
#      <1> start_x
#      <2> start_y: The minimum x/y coordinate for the rooms
#      <3> end_x
#      <4> end_y: The maximum x/y coordinate for the rooms,
#                 including the room size
#      <5> size_hallway: The minimum seperation between the
#                        rooms
#      <6> a_group_frequency: The frequencies of the room
#                             groups
#      <7> a_rooms: The array to fill with the rooms
#      <8> start_index: The index of the first room to
#                       calculate
#      <9> room_count_min: The minimum number of rooms
#      <10>room_count_max: The maximum number of rooms
#  Preconditon(s):
#      <1> start_x >= 1 + size_hallway
#      <2> start_y >= 1 + size_hallway
#      <3> end_x < MAP_SIZE - 1 - size_hallway
#      <4> end_y < MAP_SIZE - 1 - size_hallway
#      <5> size_hallway >= 1
#      <6> a_group_frequency != NULL
#      <7> a_group_frequency[ROOM_GROUP_TOTAL_FREQUENCY] >= 1
#      <8> a_rooms != NULL
#      <9> a_rooms contains at least
#          start_index + room_count_min elements
#      <10>room_count_min >= 1
#      <11>room_count_min <= room_count_max
#  Returns: The number of roolms placed.
#  Side Effect: a_rooms is set to contain the rooms that were
#               calculated.  The elements of a_rooms are used
#               in order.
#

{{
function calculateRoomsForChaoticCity (start_x, start_y,
                                       end_x, end_y,
                                       size_hallway,
                                       a_group_frequency,
                                       a_rooms, start_index,
                                       room_count_min, room_count_max)
  assert(start_x < end_x, "start_x must be < end_x")
  assert(start_y < end_y, "start_y must be < end_y")
  assert(start_x >= 1 + size_hallway,
         "start_x must be >= size_hallway + 1")
  assert(start_y >= 1 + size_hallway,
         "start_y must be >= size_hallway + 1")
  assert(end_x < MAP_SIZE - 1 - size_hallway,
         "end_x must be < MAP_SIZE - 1 - size_hallway")
  assert(end_y < MAP_SIZE - 1 - size_hallway,
         "end_y must be < MAP_SIZE - 1 - size_hallway")
  assert(size_hallway >= 1, "hallway size must be positive")
  assert(a_group_frequency ~= nil,
         "a_group_frequency cannot == nil")
  assert(a_group_frequency.total > 0,
         "total frequency must be > 0")
  assert(a_rooms ~= nil, "a_rooms cannot be nil")
  assert(room_count_min >= 1, "must place at least one room")
  assert(room_count_min <= room_count_max,
         "maximum room count cannot be less than minimum room count")

  local room_count = 0

  -- first, we try to add rooms of the right size
  for r = 0, room_count_max - 1 do
    local group = getRandomGroup(a_group_frequency)
    local size = A_ROOM_SIZE[group]

    if end_x - start_x > size then
      local added_room = addRoomForChaoticCity(start_x, start_y,
                                               end_x, end_y,
                                               size_hallway,
                                               group,
                                               a_rooms,
                                               start_index,
                                               room_count)
      if added_room == true then
        room_count = room_count + 1
      end
    end
  end

  -- if we did not get enough rooms, add some closets
  while room_count < room_count_min do
    local added_room = addRoomForChaoticCity(start_x, start_y,
                                             end_x, end_y,
                                             size_hallway,
                                             ROOM_GROUP_CLOSET,
                                             a_rooms,
                                             start_index,
                                             room_count)
    if added_room == true then
      room_count = room_count + 1
    end
  end

  return room_count
end
}}

#
#  addRoomForChaoticCity
#
#  Purpose: To attempt to a room of the specified size group to
#           the specified vector of rooms suitable for a
#           chaotic city.  The room is not added if it would
#           overlap an existing room.
#  Parameter(s):
#      <1> start_x
#      <2> start_y: The minimum x/y coordinate for the rooms
#      <3> end_x
#      <4> end_y: The maximum x/y coordinate for the rooms,
#                 including the room size
#      <5> size_hallway: The minimum seperation between the
#                        rooms
#      <6> group: The size group for the room
#      <7> a_rooms: The array to add the room to
#      <8> start_index: The index of the first room to
#                       calculate
#      <9> room_count: The current number of rooms
#  Preconditon(s):
#      <1> start_x >= 1 + size_hallway
#      <2> start_y >= 1 + size_hallway
#      <3> end_x < MAP_SIZE - 1 - size_hallway
#      <4> end_y < MAP_SIZE - 1 - size_hallway
#      <5> size_hallway >= 1
#      <6> group < ROOM_GROUP_COUNT
#      <7> end_x - start_x > A_ROOM_SIZE[group]
#      <8> end_y - start_y > A_ROOM_SIZE[group]
#      <9> a_rooms != NULL
#      <10>a_rooms contains at least
#          start_index + room_count + 1 elements
#  Returns: Whether a room was added.
#  Side Effect: N/A
#

{{
function addRoomForChaoticCity (start_x, start_y,
                                end_x, end_y,
                                size_hallway,
                                group,
                                a_rooms,
                                start_index,
                                room_count)
  assert(start_x < end_x, "start_x must be < end_x")
  assert(start_y < end_y, "start_y must be < end_y")
  assert(start_x >= 1 + size_hallway,
         "start_x must be >= size_hallway + 1")
  assert(start_y >= 1 + size_hallway,
         "start_y must be >= size_hallway + 1")
  assert(end_x < MAP_SIZE - 1 - size_hallway,
         "end_x must be < MAP_SIZE - 1 - size_hallway")
  assert(end_y < MAP_SIZE - 1 - size_hallway,
         "end_y must be < MAP_SIZE - 1 - size_hallway")
  assert(size_hallway >= 1, "hallway size must be positive")
  assert(group < ROOM_GROUP_COUNT, "Invalid room group")
  assert(end_x - start_x > A_ROOM_SIZE[group],
         "room must fit between start_x and end_x")
  assert(end_y - start_y > A_ROOM_SIZE[group],
         "room must fit between start_y and end_y")
  assert(a_rooms ~= nil, "a_rooms cannot be nil")

  local size = A_ROOM_SIZE[group]
  local range_x = end_x - (start_x + size)
  local range_y = end_y - (start_y + size)

  local x = start_x + crawl.random2(range_x + 1)
  local y = start_y + crawl.random2(range_y + 1)

  -- check for collisions with other rooms
  for i = 0, room_count - 1 do
    local index = start_index + i
    local other_size = A_ROOM_SIZE[a_rooms[index].m_group]

    -- include space for walls around rooms
    if isIntersection(x - 1,
                      y - 1,
                      size + 2 + size_hallway,
                      a_rooms[index].m_x - 1,
                      a_rooms[index].m_y - 1,
                      other_size + 2 + size_hallway) then
      -- give up if collision
      return false
    end
  end

  local new_index = start_index + room_count

  a_rooms[new_index] = createDefaultRoom(group)
  a_rooms[new_index].m_x = x
  a_rooms[new_index].m_y = y

  return true
end
}}

#
#  isIntersection
#
#  Purpose: To determine if 2 squares intersect.  Each square
#           is assumed to be of the specified size and to have
#           its minimum XY coordinates at the specified minimum
#           position, .
#  Parameter(s):
#      <1> x1
#      <2> y1: The minimum coordinate of square 1
#      <3> size1: The size of square 1
#      <4> x2
#      <5> y2: The minimum coordinate of square 2
#      <6> size2: The size of square 2
#  Preconditon(s):
#      <1> size1 >= 1
#      <2> size2 >= 1
#  Returns: Whether the two squares intersect.
#  Side Effect: N/A
#

{{
function isIntersection (x1, y1, size1, x2, y2, size2)
  assert(size1 >= 1, "Room 1 must have positive size")
  assert(size2 >= 1, "Room 2 must have positive size")

  local xp1 = x1 + size1
  local xp2 = x2 + size2
  if x1 >= xp2 or x2 >= xp1 then
    return false
  end

  local yp1 = y1 + size1
  local yp2 = y2 + size2
  if y1 >= yp2 or y2 >= yp1 then
    return false
  end

  return true
end
}}

#
#  calculateRoomOrder
#
#  Purpose: To choose an order for the specified number of
#           rooms of each room group.
#  Parameter(s):
#      <1> a_count_group: How many rooms of each group
#      <2> is_extra_wall: Whether an extra wall should be added
#      <3> count_total: The total number of rooms, including
#                       the extra wall if present
#      <4> a_rooms: The array to fill with the room information
#      <5> room_array_size: The size of the room array
#      <6> start_index: The index of the first room to set
#      <7> before_index
#      <8> after_index: The index of the room before/after the
#                       line of rooms being ordered
#  Preconditon(s):
#      <1> a_count_group != NULL
#      <2> !is_extra_wall || count_total >= 1
#      <3> a_rooms != NULL
#      <4> a_rooms contains at least count_total elements
#      <5> start_index >= 0
#      <6> start_index + count_total <= room_array_size
#      <7> before_index == NO_ROOM || before_index >= 0
#      <8> before_index == NO_ROOM ||
#          before_index < room_array_size
#      <9> before_index == NO_ROOM ||
#          before_index < start_index ||
#          before_index >= start_index + count_total
#      <10>before_index == NO_ROOM ||
#          a_rooms[before_index] ~= nil
#      <11>before_index == NO_ROOM ||
#          !a_rooms[before_index].m_is_dummy_wall
#      <12>after_index == NO_ROOM ||
#          after_index < room_array_size
#      <13>after_index == NO_ROOM || after_index >= 0
#      <14>after_index == NO_ROOM ||
#          after_index < start_index ||
#          after_index >= start_index + count_total
#      <15>after_index == NO_ROOM ||
#          a_rooms[after_index] ~= nil
#      <16>after_index == NO_ROOM ||
#          !a_rooms[after_index].m_is_dummy_wall
#  Returns: N/A
#  Side Effect: a_rooms is set to contain size and connection
#               information for the rooms.  The number of rooms
#               of each size group is that specified by
#               a_count_group.  If extra_wall is true, the
#               m_is_extra_wall flag is set one room.
#

{{
function calculateRoomOrder (a_count_group,
                             is_extra_wall,
                             count_total,
                             a_rooms,
                             room_array_size,
                             start_index,
                             before_index,
                             after_index)

  assert(a_count_group ~= nil, "a_count_group cannot be nil")
  assert(not is_extra_wall or count_total >= 1,
         "count_total must be at least 1 if there is an extra wall")
  assert(a_rooms ~= nil, "a_rooms cannot be nil")
  assert(start_index >= 0, "start_index cannot be negative")
  assert(start_index + count_total <= room_array_size,
         "room index range overruns the end of the room array")

  assert(before_index == NO_ROOM or before_index >= 0,
         "before_index cannot be neagative")
  assert(before_index == NO_ROOM or before_index < room_array_size,
         "before_index is past the end of the room array")
  assert(before_index == NO_ROOM or
         before_index < start_index or
         before_index >= start_index + count_total,
         "before_index cannot be in the part of the array being calculated")
  assert(before_index == NO_ROOM or
         a_rooms[before_index] ~= nil,
         "before_index cannot refer to a nill element")
  assert(before_index == NO_ROOM or
         not a_rooms[before_index].m_is_dummy_wall,
         "before_index cannot refer to a dummy wall")

  assert(after_index == NO_ROOM or after_index >= 0,
         "after_index cannot be neagative")
  assert(after_index == NO_ROOM or after_index < room_array_size,
         "after_index is past the end of the room array")
  assert(after_index == NO_ROOM or
         after_index < start_index or
         after_index >= start_index + count_total,
         "after_index cannot be in the part of the array being calculated")
  assert(after_index == NO_ROOM or
         a_rooms[after_index] ~= nill,
         "after_index cannot refer to a nil element")
  assert(after_index == NO_ROOM or
         not a_rooms[after_index].m_is_dummy_wall,
         "after_index cannot refer to a dummy wall")

  local ROOM_GROUP_EXTRA_WALL = 1000
  local ROOM_GROUP_UNASSIGNED = 1001

  --
  --  The general approach here is to put all the room
  --    sizes (including the extra wall) in a temporary
  --    array.  They are then assigned to the real room
  --    array in random order, being removed from the
  --    temporary array as it used.  As each room is added
  --    to the real array it is given a connection type.
  --

  -- 1. Put all the rooms in a temporary array
  local a_room_group = {}

  local place_index = 0
  if is_extra_wall then
    a_room_group[place_index] = ROOM_GROUP_EXTRA_WALL
    place_index = place_index + 1
  end

  for g = 0, ROOM_GROUP_COUNT - 1 do
    for i = 0, a_count_group[g] - 1 do
      a_room_group[place_index] = g
      place_index = place_index + 1
    end
  end

  -- 2. Choose a random order to assign rooms
  local a_order = {}
  for i = 0, count_total - 1 do
    local other_index = crawl.random2(i + 1)
    a_order[i] = a_order[other_index]
    a_order[other_index] = i
  end

  -- 3. Initialize all rooms
  for i = 0, count_total - 1 do
    local index = start_index + i
    a_rooms[index] = createDefaultRoom(ROOM_GROUP_CLOSET)
    a_rooms[index].m_group = ROOM_GROUP_UNASSIGNED
  end

  -- 4. Assign rooms
  local rooms_remaining = count_total
  for i = 0, count_total - 1 do
    local room_index = start_index + a_order[i]
    local group = a_room_group[i]

    if group == ROOM_GROUP_EXTRA_WALL then
      a_rooms[room_index].m_is_dummy_wall = true
      a_rooms[room_index].m_group = ROOM_GROUP_CLOSET
    else
      local connection_type
      local connected_to

      a_rooms[room_index].m_group = group

      connection_type = getRandomConnectionType()
      connected_to = NO_ROOM

      -- no unconnected closets
      if group == ROOM_GROUP_CLOSET and
         connection_type == CONNECTION_NONE then
        connection_type = CONNECTION_NORMAL
      end

      --
      --  Only allow a "sideways" connection
      --    if there is an appropriate room to
      --    connect to.  A room is
      --    inappropriate if:
      --  <1> it is a placeholder wall
      --  <2> it is a differant size
      --  <3> it as not been generted yet
      --

      if connection_type == CONNECTION_BEFORE then
        if room_index < start_index + 1 then
          connected_to = before_index
        else
          connected_to = room_index - 1
        end

        if connected_to == NO_ROOM or
           a_rooms[connected_to].m_group == ROOM_GROUP_UNASSIGNED or
           a_rooms[connected_to].m_is_dummy_wall or
           a_rooms[connected_to].m_group ~= group then
          connection_type = CONNECTION_NORMAL
          connected_to = NO_ROOM
        end
      end

      if connection_type == CONNECTION_AFTER then
        if room_index >= start_index + count_total - 1 then
          connected_to = after_index
        else
          connected_to = room_index + 1
        end

        if connected_to == NO_ROOM or
           a_rooms[connected_to].m_group == ROOM_GROUP_UNASSIGNED or
           a_rooms[connected_to].m_is_dummy_wall or
           a_rooms[connected_to].m_group ~= group then
          connection_type = CONNECTION_NORMAL
          connected_to = NO_ROOM
        end
      end

      a_rooms[room_index].m_connection = connection_type
      a_rooms[room_index].m_connected_to = connected_to
      if connected_to ~= NO_ROOM then
        a_rooms[connected_to].m_attached_count =
                        a_rooms[connected_to].m_attached_count + 1
      end
    end
  end
end
}}

#
#  connectDisconnectedRooms
#
#  Purpose: To change the connection on all rooms that
#           previously had a connection type of CONNECTION_NONE
#           and do not contain stairs to have  connection type
#           CONNECTION_NORMAL.
#  Parameter(s):
#      <1> a_rooms: The array of room information
#      <2> room_count: The number of rooms
#  Preconditon(s):
#      <1> a_rooms != NULL
#      <2> a_rooms contains at least room_count elements
#  Returns: N/A
#  Side Effect: The content type is checked for all rooms with
#               connection type CONNECTION_NONE.  If the room
#               does not contain staors, it is set to have
#               connection type CONNECTION_NORMAL.
#

{{
function connectDisconnectedRooms (a_rooms, room_count)
  assert(a_rooms ~= nil, "a_rooms cannot be nil")

  for i = 0, room_count - 1 do
    if a_rooms[i].m_connection == CONNECTION_NONE and
       ( not isContentStairs(a_rooms[i].m_content) or
         crawl.random2(100) >= STAIRS_DISCONNECTED_PERCENT ) then
      a_rooms[i].m_connection = CONNECTION_NORMAL
    end
  end
end
}}



########
#
#  Functions For Room Groups
#
#
#  getLargestGroup
#
#  Purpose: To determine the largest room group in the
#           specified frequency array.
#  Parameter(s):
#      <1> a_frequency: The array of frequencies
#  Preconditon(s):
#      <1> a_group_frequency != NULL
#      <2> a_group_frequency[ROOM_GROUP_TOTAL_FREQUENCY] >= 1
#  Returns: The array index corresponding to the largest room
#           group.  This is a value in the range
#           [0, ROOM_GROUP_COUNT).
#  Side Effect: N/A
#

{{
function getLargestGroup (a_group_frequency)
  assert(a_group_frequency ~= nil,
         "a_group_frequency cannot == nil")
  assert(a_group_frequency.total > 0,
         "total frequency must be > 0")

  -- Note thatr this lop counts down
  for i = ROOM_GROUP_COUNT - 1, 0, -1 do
    if a_group_frequency[i] > 0 then
      return i
    end
  end

  crawl.mpr("Error chosing largest room group: No room groups")
  return ROOM_GROUP_CLOSET
end
}}

#
#  getRoomCountTotal
#
#  Purpose: To determine the total number of rooms in all
#           groups in the specified array.
#  Parameter(s):
#      <1> a_count_group: The array of the number of rooms from
#                         each group
#  Preconditon(s):
#      <1> a_count_group != NULL
#  Returns: The total number of rooms.
#  Side Effect: N/A
#

{{
function getRoomCountTotal (a_count_group)
  assert(a_count_group ~= nil, "a_count_group cannot == nil")

  local total = 0
  for i = 0, ROOM_GROUP_COUNT - 1 do
    total = total + a_count_group[i]
  end
  return total
end
}}



########
#
#  Functions For Room Facing Directions
#
#  These functions determine which way a room should face on the
#    cross, walkways, and square ring layouts.
#
#
#  getCrossFacingDirection
#
#  Purpose: To determine the facing direction for a room on the
#           specified branch of the cross layout.  The room is
#           assumed to have the specified connection type.
#  Parameter(s):
#      <1> branch: Which branch
#      <2> connection_type: The type of connection
#  Preconditon(s):
#      <1> branch < CROSS_BRANCH_COUNT
#      <2> connection_type < CONNECTION_COUNT
#  Returns: The facing direction for the room.
#  Side Effect: N/A
#

{{
function getCrossFacingDirection (branch, connection_type)
  assert(branch < CROSS_BRANCH_COUNT,
         "branch must be less than " .. CROSS_BRANCH_COUNT)
  assert(connection_type < CONNECTION_COUNT,
         "connection_type must be less than " .. CONNECTION_COUNT)

  --
  --    1 | 5
  --  0 * | * 4
  --  ----+----
  --  2 * | * 6
  --    3 | 7
  --

  local A_FACING_NORMAL = {
    [0]=FACING_Y_PLUS,
        FACING_X_PLUS,
        FACING_Y_MINUS,
        FACING_X_PLUS,
        FACING_Y_PLUS,
        FACING_X_MINUS,
        FACING_Y_MINUS,
        FACING_X_MINUS    }

  local A_FACING_BEFORE = {
    [0]=FACING_X_PLUS,
        FACING_Y_PLUS,
        FACING_X_PLUS,
        FACING_Y_MINUS,
        FACING_X_MINUS,
        FACING_Y_PLUS,
        FACING_X_MINUS,
        FACING_Y_MINUS    }

  local A_FACING_AFTER = {
    [0]=FACING_X_MINUS,
        FACING_Y_MINUS,
        FACING_X_MINUS,
        FACING_Y_PLUS,
        FACING_X_PLUS,
        FACING_Y_MINUS,
        FACING_X_PLUS,
        FACING_Y_PLUS    }

  if connection_type == CONNECTION_NORMAL then
    return A_FACING_NORMAL[branch]
  elseif connection_type == CONNECTION_BEFORE then
    return A_FACING_BEFORE[branch]
  elseif connection_type == CONNECTION_AFTER then
    return A_FACING_AFTER[branch]
  else
    -- connection_type == CONNECTION_NONE:
    return FACING_NONE
  end
end
}}

#
#  getWalkwaysFacingDirection
#
#  Purpose: To determine the facing direction for a room on the
#           specified line of rooms of the walkways layout.
#           The room is assumed to have the specified
#           connection type.
#  Parameter(s):
#      <1> line_of_rooms: Which line of rooms
#      <2> connection_type: The type of connection
#  Preconditon(s):
#      <1> line_of_rooms < 4
#      <2> connection_type < CONNECTION_COUNT
#  Returns: The facing direction for the room.
#  Side Effect: N/A
#

{{
function getWalkwaysFacingDirection (line_of_rooms, connection_type)
  assert(line_of_rooms < WALKWAYS_CORNERS_PER_BRANCH,
         "line_of_rooms must be less than " .. WALKWAYS_CORNERS_PER_BRANCH)
  assert(connection_type < CONNECTION_COUNT,
         "connection_type must be less than " .. CONNECTION_COUNT)

  --
  --    |
  --   0|2
  --  --+--
  --   1|3
  --    |
  --

  local A_FACING_NORMAL = {
    [0]=FACING_X_PLUS,
        FACING_X_PLUS,
        FACING_X_MINUS,
        FACING_X_MINUS    }

  local A_FACING_BEFORE = {
    [0]=FACING_Y_PLUS,
        FACING_Y_MINUS,
        FACING_Y_PLUS,
        FACING_Y_MINUS    }

  local A_FACING_AFTER = {
    [0]=FACING_Y_MINUS,
        FACING_Y_PLUS,
        FACING_Y_MINUS,
        FACING_Y_PLUS    }

  if connection_type == CONNECTION_NORMAL then
    return A_FACING_NORMAL[line_of_rooms]
  elseif connection_type == CONNECTION_BEFORE then
    return A_FACING_BEFORE[line_of_rooms]
  elseif connection_type == CONNECTION_AFTER then
    return A_FACING_AFTER[line_of_rooms]
  else
    -- connection_type == CONNECTION_NONE:
    return FACING_NONE
  end
end
}}

#
#  getSquareRingFacingDirection
#
#  Purpose: To determine the facing direction for a room on the
#           outside of the square ring layout.  The room is
#           assumed to be on the specified side of the layout
#           and to have the specified connection type.  For the
#           inner ring, use the oppoisite side of the layout.
#  Parameter(s):
#      <1> line_of_rooms: Which line of rooms
#      <2> connection_type: The type of connection
#  Preconditon(s):
#      <1> room_line < SQUARE_RING_ROOM_LINE_COUNT
#      <2> connection_type < CONNECTION_COUNT
#  Returns: The facing direction for the room.
#  Side Effect: N/A
#

{{
function getSquareRingFacingDirection (room_line, connection_type)
  assert(room_line < SQUARE_RING_ROOM_LINE_COUNT,
         "room_line must be less than " .. SQUARE_RING_ROOM_LINE_COUNT)
  assert(connection_type < CONNECTION_COUNT,
         "connection_type must be less than " .. CONNECTION_COUNT)

  --
  --     2----->
  --  0 +-------+ 1
  --  | |*6--->*| |
  --  | |4     5| |
  --  | |v     v| |
  --  | |*7--->*| |
  --  v +-------+ v
  --     3----->
  --

  local A_FACING_NORMAL = {
    [0]=FACING_X_PLUS,
        FACING_X_MINUS,
        FACING_Y_PLUS,
        FACING_Y_MINUS,
        FACING_X_MINUS,
        FACING_X_PLUS,
        FACING_Y_MINUS,
        FACING_Y_PLUS    }

  local A_FACING_BEFORE = {
    [0]=FACING_Y_MINUS,
        FACING_Y_MINUS,
        FACING_X_MINUS,
        FACING_X_MINUS,
        FACING_Y_MINUS,
        FACING_Y_MINUS,
        FACING_X_MINUS,
        FACING_X_MINUS    }

  local A_FACING_AFTER = {
    [0]=FACING_Y_PLUS,
        FACING_Y_PLUS,
        FACING_X_PLUS,
        FACING_X_PLUS,
        FACING_Y_PLUS,
        FACING_Y_PLUS,
        FACING_X_PLUS,
        FACING_X_PLUS    }

  if connection_type == CONNECTION_NORMAL then
    return A_FACING_NORMAL[room_line]
  elseif connection_type == CONNECTION_BEFORE then
    return A_FACING_BEFORE[room_line]
  elseif connection_type == CONNECTION_AFTER then
    return A_FACING_AFTER[room_line]
  else
    -- connection_type == CONNECTION_NONE:
    return FACING_NONE
  end
end
}}



########
#
#  Functions For Room Contents
#
#  These functions assign content types to rooms.  Content types
#    are always assigned in the same order:
#      <1> Stairs (up and down)
#      <2> Entries to branches and portal vaults
#      <3> Solid/filled in/non-existant rooms
#      <4> Everything else, by probabilities
#
#  Each of these has its own algorithm.  In addition, some
#    layouts may handle some of these differantly.  For example,
#    the maze layout always places the stairs in the corners.
#
#  There are also a couple of extra room-content-related
#    functions here.  One removes the dead-end hallwys from the
#    maze and the other determines if a content type represents
#    a room with stairs.
#
#  These functions tend to be long and complicated.  The
#    complexity comes from 3 broad areas:
#      <1> special cases requiring exceptions in the code
#      <2> making the content type assignment configurable
#      <3> avoiding any bias in room contents based on the
#          order of the rooms in the array
#
#
#  calculateContentStairs
#
#  Purpose: To choose which rooms will contain the stairs for
#           this map.
#  Parameter(s):
#      <1> a_rooms: The array of room information
#      <2> room_count: The number of rooms
#      <3> depth: The depth of the current map within the
#                 branch
#  Preconditon(s):
#      <1> a_rooms != NULL
#      <2> room_count >= 6
#      <3> a_rooms contains at least room_count elements
#  Returns: N/A
#  Side Effect: Rooms in a_rooms are set to have a content
#               type indicating stairs.  A total of 3 up stairs
#               and 3 down stairs are placed.  Stairs are more
#               likely to be placed in groups of 3 at deeper
#               depths.  Down stairs are placed in rooms with
#               connection type CONNECTION_NONE if possible.
#               However, at least one down stairs will be
#               placed in a room connected to the rest of the
#               map.
#

{{
function calculateContentStairs (a_rooms, room_count, depth)
  assert(a_rooms ~= nil, "a_rooms cannot be nil")
  assert(room_count >= 6, "room_count must be at least 6")

  if isStairsTogetherUp(depth) then
    calculateContentStairsTogether(a_rooms, room_count,
                                   CONTENT_STAIRS_UP_3)
  else
    calculateContentStairsSeperate(a_rooms, room_count,
                                   CONTENT_STAIRS_UP_1A, false)
    calculateContentStairsSeperate(a_rooms, room_count,
                                   CONTENT_STAIRS_UP_1B, false)
    calculateContentStairsSeperate(a_rooms, room_count,
                                   CONTENT_STAIRS_UP_1C, false)
  end

  if isStairsTogetherDown(depth) then
    calculateContentStairsTogether(a_rooms, room_count,
                                   CONTENT_STAIRS_DOWN_3)
  else
    calculateContentStairsSeperate(a_rooms, room_count,
                                   CONTENT_STAIRS_DOWN_1A, false)
    calculateContentStairsSeperate(a_rooms, room_count,
                                   CONTENT_STAIRS_DOWN_1B, true)
    calculateContentStairsSeperate(a_rooms, room_count,
                                   CONTENT_STAIRS_DOWN_1C, true)
  end
end
}}

#
#  calculateContentStairsTogether
#
#  Purpose: To choose which room for this map will contain all
#           3 stairs going in the specified direction.
#  Parameter(s):
#      <1> a_rooms: The array of room information
#      <2> room_count: The number of rooms
#      <3> stairs: The content type for the stairs
#  Preconditon(s):
#      <1> a_rooms != NULL
#      <2> room_count >= 1
#      <3> a_rooms contains at least room_count elements
#      <4> a_rooms contains at least 1 unassigned room
#      <5> stairs == CONTENT_STAIRS_UP_3 ||
#          stairs == CONTENT_STAIRS_DOWN_3
#  Returns: N/A
#  Side Effect: One unassigned room is set to contain content
#               type stairs.  That room is modified to have
#               connection type CONNECTION_NORMAL.
#

{{
function calculateContentStairsTogether (a_rooms, room_count, stairs)
  assert(a_rooms ~= nil, "a_rooms cannot be nil")
  assert(room_count >= 6, "room_count must be at least 6")
  assert(stairs == CONTENT_STAIRS_UP_3 or
         stairs == CONTENT_STAIRS_DOWN_3, "Invalid stairs type")

  local index = crawl.random2(room_count)
  while a_rooms[index].m_is_dummy_wall or
        a_rooms[index].m_content ~= CONTENT_UNASSIGNED or
        a_rooms[index].m_group == ROOM_GROUP_CLOSET do

    index = crawl.random2(room_count)
  end

  a_rooms[index].m_connection = CONNECTION_NORMAL
  a_rooms[index].m_content = stairs
end
}}

#
#  calculateContentStairsSeperate
#
#  Purpose: To choose which a room for this map to contain
#           a single set of stairs going in the specified
#           direction.
#  Parameter(s):
#      <1> a_rooms: The array of room information
#      <2> room_count: The number of rooms
#      <3> content: The content type for the stairs
#      <4> allow_disconnected: Whether the stairs can be
#                        placed in a room with no other entrance
#  Preconditon(s):
#      <1> a_rooms != NULL
#      <2> room_count >= 1
#      <3> a_rooms contains at least room_count elements
#      <4> a_rooms contains at least 1 unassigned room
#      <5> content == CONTENT_STAIRS_UP_1A   ||
#          content == CONTENT_STAIRS_DOWN_1A ||
#          content == CONTENT_STAIRS_UP_1B   ||
#          content == CONTENT_STAIRS_DOWN_1B ||
#          content == CONTENT_STAIRS_UP_1C   ||
#          content == CONTENT_STAIRS_DOWN_1C
#  Returns: N/A
#  Side Effect: An unassigned room is set to contain content
#               type stairs.  If allow_disconnected is true, a
#               room with connection type CONNECTION_NONE is
#               chosen if possible.  If allow_disconnected is
#               false, all stairs are placed in rooms with
#               connection type CONNECTION_NORMAL.
#

{{
function calculateContentStairsSeperate (a_rooms, room_count,
                                         stairs, allow_disconnected)
  assert(a_rooms ~= nil, "a_rooms cannot be nil")
  assert(room_count >= 6, "room_count must be at least 6")
  assert(stairs == CONTENT_STAIRS_UP_1A   or
         stairs == CONTENT_STAIRS_DOWN_1A or
         stairs == CONTENT_STAIRS_UP_1B   or
         stairs == CONTENT_STAIRS_DOWN_1B or
         stairs == CONTENT_STAIRS_UP_1C   or
         stairs == CONTENT_STAIRS_DOWN_1C, "Invalid stairs type")

  local unconnectea_rooms = 0
  local connectea_rooms = 0
  for r = 0, room_count - 1 do
    if not a_rooms[r].m_is_dummy_wall and
       a_rooms[r].m_content == CONTENT_UNASSIGNED then

      if a_rooms[r].m_connection == CONNECTION_NONE then
        unconnectea_rooms = unconnectea_rooms + 1
      elseif a_rooms[r].m_connection == CONNECTION_NORMAL then
        connectea_rooms   = connectea_rooms   + 1
      end
    end
  end

  local desired_connection
  local spots_along
  local index
  if unconnectea_rooms > 0 and allow_disconnected then
    desired_connection = CONNECTION_NONE
    spots_along = crawl.random2(unconnectea_rooms)
    unconnectea_rooms = unconnectea_rooms - 1
  elseif connectea_rooms > 0 then
    desired_connection = CONNECTION_NORMAL
    spots_along = crawl.random2(connectea_rooms)
    connectea_rooms = connectea_rooms - 1
  else
    -- just change some room to the correct type

    -- pick a room
    index = crawl.random2(room_count)
    while a_rooms[index].m_is_dummy_wall or
          a_rooms[index].m_content ~= CONTENT_UNASSIGNED do
      index = crawl.random2(room_count)
    end

    -- add the stairs
    a_rooms[index].m_connection = CONNECTION_NORMAL
    a_rooms[index].m_content = stairs

    -- nothing more to do for this stairs
    return
  end

  -- we only get here if we didn't force a door

  -- find the index of the room
  index = NO_ROOM
  for i = 0, room_count - 1 do
    if not a_rooms[i].m_is_dummy_wall and
       a_rooms[i].m_connection == desired_connection and
       a_rooms[i].m_content == CONTENT_UNASSIGNED then

      if spots_along == 0 then
        index = i
      else
        spots_along = spots_along - 1
      end
    end
  end

  a_rooms[index].m_content = stairs
end
}}

#
#  calculateContentBranchPortal
#
#  Purpose: To choose the rooms to contain the entries to any
#           branches or portal vaults.
#  Parameter(s):
#      <1> a_rooms: The array of room information
#      <2> room_count: The number of rooms
#      <3> a_entries: The branch and/or portal entries to add
#  Preconditon(s):
#      <1> a_rooms != NULL
#      <2> a_rooms contains at least room_count elements
#  Returns: N/A
#  Side Effect: A room in a_rooms is set to have each content
#               type in entries.  Larger rooms are chosen if
#               possible.
#

{{
function calculateContentBranchPortal (a_rooms, room_count, a_entries)
  assert(a_rooms ~= nil, "a_rooms cannot be nil")
  assert(a_entries ~= nil, "a_entries cannot be nil")

  for i = 0, a_entries.count - 1 do
    local largest_group = ROOM_GROUP_CLOSET
    local largest_count = 0
    local chosen_index = NO_ROOM

   -- choose a random room of the largest group
    for r = 0, room_count - 1 do
      if not a_rooms[r].m_is_dummy_wall and
         a_rooms[r].m_content == CONTENT_UNASSIGNED then

        local group = a_rooms[r].m_group

        if group > largest_group then
          -- this is a larger group, so it is the room
          largest_group = group
          largest_count = 1
          chosen_index = r
        elseif group == largest_group then
          -- another room of the largest group, so a chance of switching
          largest_count = largest_count + 1
          if crawl.random2(largest_count) < 1 then
            chosen_index = r
          end
        end
      end
    end

    if chosen_index == NO_ROOM then
      -- all rooms are set, let vault placer add entry
      return
    else
      -- add the room
      a_rooms[chosen_index].m_content = a_entries[i]
    end
  end
end
}}


#
#  calculateContentSerialVault
#
#  Purpose: To choose if this map contains a serial vault and,
#           if so, which serial vault and which rooms it is to
#           be in.
#  Parameter(s):
#      <1> a_rooms: The array of room information
#      <2> room_count: The number of rooms
#  Preconditon(s):
#      <1> a_rooms != NULL
#      <2> a_rooms contains at least room_count elements
#  Returns: N/A
#  Side Effect: The serial vault for this map, if any, is
#               selected.  The content type for the appropriate
#               number of rooms in a_rooms is set to the
#               content type for the selected serial vault.
#

{{
function calculateContentSerialVault(a_rooms, room_count)
  assert(a_rooms ~= nil, "a_rooms cannot be nil")

  local ROOM_SIZE_COUNT = A_ROOM_SIZE[ROOM_GROUP_COUNT - 1] + 1

  a_room_size_count = {}
  a_group_for_size  = {}

  for s = 0, ROOM_SIZE_COUNT - 1 do
    a_room_size_count[s] = 0
    a_group_for_size[s] = NO_ROOM
  end

  for g = 0, ROOM_GROUP_COUNT - 1 do
    a_group_for_size[A_ROOM_SIZE[g]] = g
  end

  for r = 0, room_count - 1 do
    if not a_rooms[r].m_is_dummy_wall and
       a_rooms[r].m_content == CONTENT_UNASSIGNED then

      local size = A_ROOM_SIZE[a_rooms[r].m_group]
      a_room_size_count[size] = a_room_size_count[size] + 1
    end
  end

  --
  --  We only add a serial vault if the right rooms are
  --    available, so we use a base chance higher than 1%,
  --    based on how common rooms of the required size(s)
  --    for the serial vault are.
  --
  --  We are using actual room sizes instead of size
  --    groups so that adding a new room size group does
  --    not break all existing serial vaults.
  --

  local chosen = crawl.random2(200)

--  if chosen < 16 then
--    --
--    --  miniwizlab serial vault
--    --
--    --  We place a 7x7 room and 1-3 4x4 rooms.
--    --
--
--    if a_room_size_count[7] >= 1 and a_room_size_count[4] >= 1 then
--
--      setRandomRoomToContent(a_rooms, room_count,
--                             a_group_for_size[7],
--                             CONTENT_SERIAL_MINIWIZLAB)
--
--      setRandomRoomToContent(a_rooms, room_count,
--                             a_group_for_size[4],
--                             CONTENT_SERIAL_MINIWIZLAB)
--      if a_room_size_count[4] >= 2 and crawl.random2(3) < 2 then
--        setRandomRoomToContent(a_rooms, room_count,
--                               a_group_for_size[4],
--                               CONTENT_SERIAL_MINIWIZLAB)
--
--        if a_room_size_count[4] >= 3 and crawl.random2(2) < 1 then
--          setRandomRoomToContent(a_rooms, room_count,
--                                 a_group_for_size[4],
--                                 CONTENT_SERIAL_MINIWIZLAB)
--        end
--      end
--    end

  if chosen < 4 then

    --
    -- crystal serial vault
    --


    if a_room_size_count[10] >= 3 then
       setRandomRoomToContent(a_rooms, room_count,
                             a_group_for_size[10],
                             CONTENT_SERIAL_CRYSTAL)
      setRandomRoomToContent(a_rooms, room_count,
                             a_group_for_size[10],
                             CONTENT_SERIAL_CRYSTAL)
      setRandomRoomToContent(a_rooms, room_count,
                             a_group_for_size[10],
                             CONTENT_SERIAL_CRYSTAL)
    end
  elseif chosen < 5 then

    --
    -- serial_hangedman_research
    --

    if a_room_size_count[7] >= 4 then
       local count = 4 + crawl.random2(3)
       if count > a_room_size_count[7] then
           count = a_room_size_count[7]
       end
       for i = 1, count do
           setRandomRoomToContent(a_rooms, room_count,
                                  a_group_for_size[7],
                                  CONTENT_SERIAL_MAGIC_RESEARCH)
       end
    end
  end
end
}}

#
#  setRandomRoomToContent
#
#  Purpose: To set a random room unassigned room with the
#           specified room group to have the specified content
#           type.  Rooms that are dummy walls are not
#           considered.
#  Parameter(s):
#      <1> a_rooms: The array of room information
#      <2> room_count: The number of rooms
#      <3> group: The room group
#      <4> content: THe content type
#  Preconditon(s):
#      <1> a_rooms != NULL
#      <2> a_rooms contains at least room_count elements
#      <3> group < ROOM_GROUP_COUNT
#      <4> There is at least one unassigned room in a_rooms
#           with room group group
#      <5> content < CONTENT_VALID_COUNT
#  Returns: N/A
#  Side Effect: A random room in a_rooms with room group group
#               is set to have content type content.
#

{{
function setRandomRoomToContent(a_rooms, room_count, group, content)
  assert(a_rooms ~= nil, "a_rooms cannot be nil")
  assert(group < ROOM_GROUP_COUNT, "Invalid group " .. group)
  assert(content < CONTENT_VALID_COUNT,
         "Invalid content type " .. content)

  local count_so_far = 0
  local chosen_index = NO_ROOM

  for r = 0, room_count - 1 do
    if not a_rooms[r].m_is_dummy_wall and
       a_rooms[r].m_content == CONTENT_UNASSIGNED and
       a_rooms[r].m_group == group then

      count_so_far = count_so_far + 1
      if crawl.random2(count_so_far) < 1 then
        chosen_index = r
      end
    end
  end

  assert(chosen_index ~= NO_ROOM,
         "no unassigned room of group " .. group .. " in a_rooms")
  a_rooms[chosen_index].m_content = content
end
}}

#
#  calculateContentSolid
#
#  Purpose: To choose the rooms to have content type solid
#          rooms based on the specified probabilities.
#  Parameter(s):
#      <1> a_rooms: The array of room information
#      <2> room_count: The number of rooms
#      <3> a_content_frequency: The frequency of differant room
#                               content types
#      <4> content_solid_frequency: The frequency of a room
#                                   being filled with solid
#                                   wall
#  Preconditon(s):
#      <1> a_rooms != NULL
#      <2> a_rooms contains at least room_count elements
#      <3> a_content_frequency != NULL
#  Returns: N/A
#  Side Effect: A number of rooms in a_rooms are set to have a
#               content type of CONTENT_SOLID.  The number of
#               rooms is based on a_probability.  Only rooms
#               that have nothing connected to them and content
#               type CONTENT_UNASSIGNED are considered.
#               Connections from now-solid rooms are removed.
#

{{
function calculateContentSolid (a_rooms, room_count,
                                a_content_frequency,
                                content_solid_frequency)

  assert(a_rooms ~= nil, "a_rooms cannot be nil")
  assert(a_content_frequency ~= nil,
         "a_content_frequency cannot be nil")

  --
  --  1. Count the unassigned and available rooms
  --
  --  Available rooms are unassigned and do not have another
  --    room attached to them
  --

  local total_unassignea_rooms = 0
  local total_available_rooms = 0
  for r = 0, room_count - 1 do
    if not a_rooms[r].m_is_dummy_wall and
       a_rooms[r].m_content == CONTENT_UNASSIGNED then

      total_unassignea_rooms = total_unassignea_rooms + 1
      if a_rooms[r].m_attached_count == 0 then
        total_available_rooms = total_available_rooms + 1
      end
    end
  end

  --
  --  2. Determine how many rooms to make solid
  --

  local content_total_frequency = content_solid_frequency
  for p = 0, CONTENT_PROBABILITY_COUNT - 1 do
    content_total_frequency = content_total_frequency + a_content_frequency[p]
  end
  local solid_fraction = content_solid_frequency / content_total_frequency
  local solid_count = math.floor(solid_fraction * total_unassignea_rooms)

  --
  --  3.  Mark some rooms as solid
  --

  for i = 0, solid_count - 1 do
    if total_available_rooms <= 0 then
      -- there are no more rooms to make solid
      return
    end

    local chosen = crawl.random2(total_available_rooms)

    for r = 0, room_count - 1 do
      if not a_rooms[r].m_is_dummy_wall and
         a_rooms[r].m_content == CONTENT_UNASSIGNED and
         a_rooms[r].m_attached_count == 0 then

        if chosen == 0 then
          a_rooms[r].m_content = CONTENT_SOLID
          total_available_rooms = total_available_rooms - 1

          local connected_to = a_rooms[r].m_connected_to
          if connected_to ~= NO_ROOM then
            a_rooms[r].m_connected_to = NO_ROOM

            -- check if we now have another available room
            a_rooms[connected_to].m_attached_count =
                    a_rooms[connected_to].m_attached_count - 1
            if not a_rooms[connected_to].m_is_dummy_wall and
               a_rooms[connected_to].m_content == CONTENT_UNASSIGNED and
               a_rooms[connected_to].m_attached_count == 0 then
              total_available_rooms = total_available_rooms + 1
            end
          end

          -- we have found the room, so give up
          break
        else
          chosen = chosen - 1
        end
      end
    end
  end
end
}}

#
#  calculateContentProbability
#
#  Purpose: To choose the content types for the unassigned
#           rooms on this map based on the specified
#           probabilities.
#  Parameter(s):
#      <1> a_rooms: The array of room information
#      <2> room_count: The number of rooms
#      <3> a_content_frequency: The frequency of differant room
#                               content types
#  Preconditon(s):
#      <1> a_rooms != NULL
#      <2> a_rooms contains at least room_count elements
#      <3> a_content_frequency != NULL
#  Returns: N/A
#  Side Effect: All rooms in a_rooms are set to have a content
#               type chosen randomly based on a_probability.
#

{{
function calculateContentProbability (a_rooms, room_count, a_content_frequency)
  assert(a_rooms ~= nil, "a_rooms cannot be nil")
  assert(a_content_frequency ~= nil, "a_content_frequency cannot be nil")

  local NO_CONTENT_CHOSEN = 1.0e20
  local PROBABILITY_ADDED = 0.1

  --  1. Count the unassigned rooms
  local total_unassignea_rooms = 0
  for i = 0, room_count - 1 do
    if not a_rooms[i].m_is_dummy_wall and
       a_rooms[i].m_content == CONTENT_UNASSIGNED then

      total_unassignea_rooms = total_unassignea_rooms + 1
    end
  end

  --
  --  2. Choose a random order to assign rooms
  --
  --  First, we find the indexes of all unassigned rooms.
  --    Then we put them into random order.
  --

  local a_order = {}

  -- find room indexes
  local rooms_skipped = 0
  for i = 0, room_count - 1 do
    if a_rooms[i].m_is_dummy_wall or
       a_rooms[i].m_content ~= CONTENT_UNASSIGNED then

      rooms_skipped = rooms_skipped + 1
    else
      a_order[i - rooms_skipped] = i
    end
  end

  -- randomize order
  for i = 0, total_unassignea_rooms - 1 do
    local other_index = crawl.random2(i + 1)
    local temp = a_order[i]
    a_order[i] = a_order[other_index]
    a_order[other_index] = temp
  end

  --
  --  3. Assign random content types to the rooms
  --
  --  The rooms are chosen by repeatedly selecting the
  --    room that is farthest "behind" in the number
  --    selected,  If the rooms are close enough to
  --    balanced, a room is chosen at random.
  --

  -- find total probability
  local probability_total = 0
  for p = 0, CONTENT_PROBABILITY_COUNT - 1 do
    probability_total = probability_total + a_content_frequency[p]
  end

  -- initialize assigned counts to 0
  local assigned_total = 0
  local a_assigned_type = {}
  for p = 0, CONTENT_PROBABILITY_COUNT - 1 do
    a_assigned_type[p] = 0
  end

  for i = 0, total_unassignea_rooms - 1 do
    -- calculate which type is farthest behind
    local a_behind = {}
    local farthest_behind = -1.0e20
    local farthest_index = NO_CONTENT_CHOSEN

    for p = 0, CONTENT_PROBABILITY_COUNT - 1 do
      local desired = i * a_content_frequency[p] / probability_total
      a_behind[p] = desired - a_assigned_type[p]

      -- skip room type with probability 0 entirely (this matters!)
      if a_content_frequency[p] == 0 then
        a_behind[p] = -1.0e20
      end

      if a_behind[p] > farthest_behind then
        farthest_behind = a_behind[p]
        farthest_index = p
      end
    end

    -- if a room type has fallen too far behind and needs to catch up
    if farthest_behind >= CONTENT_PROBABILITY_MAX_VARIATION then
      -- choose the farthest-behind content type

      local index = a_order[i]
      a_rooms[index].m_content = farthest_index
      a_assigned_type[farthest_index] = a_assigned_type[farthest_index] + 1
      assigned_total = assigned_total + 1

    else
      -- choose a content type randomly based on "behind"-ness

      -- figure out the total probability to chose from
      local total_probability = 0.0
      for p = 0, CONTENT_PROBABILITY_COUNT - 1 do
        local chance = a_behind[p] + PROBABILITY_ADDED

        if chance > 0 then
          total_probability = total_probability + chance
        end
      end

      -- pick a content type based on that probability
      local chosen = crawl.random2(total_probability)
      for p = 0, CONTENT_PROBABILITY_COUNT - 1 do
        local chance = a_behind[p] + PROBABILITY_ADDED

        if chosen < chance then
          local index = a_order[i]
          a_rooms[index].m_content = p
          a_assigned_type[p] = a_assigned_type[p] + 1
          assigned_total = assigned_total + 1
          break
        elseif chance > 0 then
          -- we don't want to increase our count if we hit a chance < 0
          chosen = chosen - chance
        end
      end
    end

    -- Finished assigning a room (finally!)
  end
end
}}

#
#  makeAllDeadEndHallwaysSolid
#
#  Purpose: To change the content type of all dead-end rooms
#           with content type CONTENT_HALLWAY to CONTENT_SOLID.
#           The starting room for the maze layout will not be
#           changed even if it is a dead end because it always
#           has another room attached to it.
#  Parameter(s):
#      <1> a_rooms: The array of room information
#      <2> room_count: The number of rooms
#  Preconditon(s):
#      <1> a_rooms != NULL
#      <2> a_rooms contains at least room_count elements
#  Returns: N/A
#  Side Effect: All rooms in a_rooms that have content type
#               CONTENT_HALLWAY and no attached rooms are set
#               to have content type CONTENT_SOLID.
#               Connections from the now-solid rooms are
#               removed and the the newly-modified room it was
#               attached to is rechecked.
#

{{
function makeAllDeadEndHallwaysSolid (a_rooms, room_count)
  assert(a_rooms ~= nil, "a_rooms cannot be nil")

  -- we look for hallways starting in each position
  for r = 0, room_count - 1 do

    -- look for dead ends everywhere
    if not a_rooms[r].m_is_dummy_wall and
       a_rooms[r].m_content == CONTENT_HALLWAY and
       a_rooms[r].m_attached_count == 0 then

      --  If we find one, follow it back and remove it until we
      --    reach a room or juction.

      -- we need a seperate index to follow the hallway
      local current = r
      while not a_rooms[current].m_is_dummy_wall and
            a_rooms[current].m_content == CONTENT_HALLWAY and
            a_rooms[current].m_attached_count == 0 do

        local next = a_rooms[current].m_connected_to

        -- remove this room
        a_rooms[current].m_content = CONTENT_SOLID
        a_rooms[current].m_connected_to = NO_ROOM

        a_rooms[next].m_attached_count = a_rooms[next].m_attached_count - 1

        -- and move on to the next
        current = next
      end
    end
  end
end
}}

#
#  isContentStairs
#
#  Purpose: To determine the whether the specified content
#           type indicates a room containing stairs.
#  Parameter(s):
#      <1> contents: The room content type
#  Preconditon(s):
#      <1> contents < CONTENT_COUNT
#  Returns: Whether a room of content type content contains a
#           set of stairs.
#  Side Effect: N/A
#

{{
function isContentStairs (content)
  assert(content < CONTENT_COUNT, "Invalid content type")

  if content ==  CONTENT_STAIRS_UP_1A   or
     content ==  CONTENT_STAIRS_DOWN_1A or
     content ==  CONTENT_STAIRS_UP_1B   or
     content ==  CONTENT_STAIRS_DOWN_1B or
     content ==  CONTENT_STAIRS_UP_1C   or
     content ==  CONTENT_STAIRS_DOWN_1C or
     content ==  CONTENT_STAIRS_UP_3    or
     content ==  CONTENT_STAIRS_DOWN_3 then
    return true
  else
    return false
  end
end
}}



########
#
#  Functions for Adding Rooms to the Map
#
#  Believe it or not, everything so far has just manipulated
#    internal data structures.  This is where they turn into
#    actual glyphs and subvaults.
#
#
#  mapAddRoom
#
#  Purpose: To add a room of the specified group at the
#           specified position with the specified facing
#           direction with the specified content type.  The
#           position is taken to be the minimum x/y-coordinate
#           of the room proper.  This does not include walls
#           (including doors), padding, etc.  The room is
#           filled with an appropriate subvault.
#  Parameter(s):
#      <1> e: The global enviroment
#      <2> x
#      <3> y: The minimum x/y coordinate
#      <4> group: The size group for the room
#      <5> facing: The facing value for the room
#      <6> is_room_attached: Whether there are room(s)
#                            attached to this room
#      <7> content: The room content type
#  Preconditon(s):
#      <1> x > 0
#      <2> y > 0
#      <3> x < MAP_SIZE - 1
#      <4> y < MAP_SIZE - 1
#      <5> group < ROOM_GROUP_COUNT
#      <6> facing < FACING_VALID_COUNT
#      <7> content < CONTENT_VALID_COUNT
#  Returns: N/A
#  Side Effect: A room of size group group with facing
#               value facing is added at position
#               (x, y) using an appropriate subvault for
#               content type content.  A string containing
#               the tag for the subvault to use is then
#               printed.
#

{{
function mapAddRoom (e, x, y, group, facing, is_room_attached, content)
  assert(x > 0, "The x-coordinate for the room must be > 0")
  assert(y > 0, "The y-coordinate for the room must be > 0")
  assert(x < MAP_SIZE - 1,
         "The x-coordinate for the room must be < MAP_SIZE - 1")
  assert(y < MAP_SIZE - 1,
         "The y-coordinate for the room must be < MAP_SIZE - 1")
  assert(group < ROOM_GROUP_COUNT, "Invalid group " .. group)
  assert(facing < FACING_VALID_COUNT, "Invalid facing direction " .. facing)
  assert(content < CONTENT_VALID_COUNT, "Invalid content type " .. content)

  if content == CONTENT_SOLID then
    -- don't do anything for solid rooms
    return
  end

  local room_size = A_ROOM_SIZE[group]
  local glyph_room = 'c'

  if content == CONTENT_VANISH then
    -- remove even the walls
    local x_min = x - 1
    local y_min = x - 1
    local x_max = x + room_size
    local y_max = y + room_size
    e.fill_area{x1=x_min, y1=y_min, x2=x_max, y2=y_max, fill='.'}
    return
  end

  local door_type = DOOR_TYPE_SPIN

  if facing == FACING_X_MINUS or
     facing == FACING_X_PLUS  or
     facing == FACING_Y_MINUS or
     facing == FACING_Y_PLUS then

    door_type = getRandomDoorType(not is_room_attached, false)

    -- all closets have door type spin
    if group == ROOM_GROUP_CLOSET then
      door_type = DOOR_TYPE_SPIN
    end

    -- change door type to spin if no such subvault
    if not isSubvaultForRoom(group, door_type, content, facing) then
      door_type = DOOR_TYPE_SPIN
    end

    mapAddRoomDirection(e, x, y, group, facing,
                        is_room_attached, glyph_room, door_type)

  elseif facing == FACING_CORNER_XM_YM or
         facing == FACING_CORNER_XP_YM or
         facing == FACING_CORNER_XM_YP or
         facing == FACING_CORNER_XP_YP then

    door_type = getRandomDoorType(not is_room_attached, false)

    -- all closets have door type spin
    if group == ROOM_GROUP_CLOSET then
      door_type = DOOR_TYPE_SPIN
    end

    -- change door type to spin if no such subvault
    if not isSubvaultForRoom(group, door_type, content, facing) then
      door_type = DOOR_TYPE_SPIN
    end

    mapAddRoomCorner(e, x, y, group, facing,
                     is_room_attached, glyph_room, door_type)

  elseif facing == FACING_CITY then

    door_type = getRandomDoorType(true, true)

    -- all closets have door type spin or city
    if group == ROOM_GROUP_CLOSET and door_type ~= DOOR_TYPE_CITY then
      door_type = DOOR_TYPE_SPIN
    end

    -- change door type to spin if no such subvault
    if not isSubvaultForRoom(group, door_type, content, facing) then
      door_type = DOOR_TYPE_SPIN
    end

    mapAddRoomCity(e, x, y, group, facing,
                   is_room_attached, glyph_room, door_type)

  elseif facing == FACING_NONE then

    door_type = DOOR_TYPE_SPIN
    mapAddRoomNone(e, x, y, group, facing,
                   is_room_attached, glyph_room, door_type)

  end

  -- finally, we replace the room with an appropriate subvault

  -- if it is a stairs vault, we set the stairs type
  if content == CONTENT_STAIRS_UP_1A then
    dgn.persist.vault_current_stairs_glyph = '{'
  elseif content == CONTENT_STAIRS_DOWN_1A then
    dgn.persist.vault_current_stairs_glyph = '}'
  elseif content == CONTENT_STAIRS_UP_1B then
    dgn.persist.vault_current_stairs_glyph = '('
  elseif content == CONTENT_STAIRS_DOWN_1B then
    dgn.persist.vault_current_stairs_glyph = ')'
  elseif content == CONTENT_STAIRS_UP_1C then
    dgn.persist.vault_current_stairs_glyph = '['
  elseif content == CONTENT_STAIRS_DOWN_1C then
    dgn.persist.vault_current_stairs_glyph = ']'
  end

  -- now, the actual subvault call
  local subvault_tag = getSubvaultTag(group, door_type, content, facing)
  e.subvault(glyph_room .. " : " .. subvault_tag)
  -- just to be safe...
  e.subst(glyph_room .. " : x")
end
}}

#
#  mapAddRoomDirection
#  mapAddRoomCorner
#  mapAddRoomCity
#  mapAddRoomNone
#
#  Purpose: To draw a room of the specified group at the
#           specified position with the specified facing
#           direction and door type with the specified glyph.
#  Parameter(s):
#      <1> e: The global enviroment
#      <2> x
#      <3> y: The minimum x/y coordinate
#      <4> group: The size group for the room
#      <5> facing: The facing value for the room
#      <6> is_room_attached: Whether there are room(s)
#                            attached to this room
#      <7> glyph: The glyph to draw the room with
#      <8> door_type: The way this room is attached to the
#                     rest of the map
#  Preconditon(s):
#      <1> x > 0
#      <2> y > 0
#      <3> x < MAP_SIZE - 1
#      <4> y < MAP_SIZE - 1
#      <5> group < ROOM_GROUP_COUNT
#      <6> facing < FACING_VALID_COUNT
#      <7> door_type < DOOR_TYPE_COUNT
# DIR  <8> facing < FACING_DIRECTION_COUNT
#      <9> door_type != DOOR_TYPE_CITY
# CORN <8> facing >= FACING_CORNER_XM_YM &&
#          facing <= FACING_CORNER_XP_YP
#      <9> door_type != DOOR_TYPE_CITY
# CITY <8> facing == FACING_CITY
# NONE <8> facing == FACING_NONE
#      <9> door_type == DOOR_TYPE_SPIN
#  Returns: N/A
#  Side Effect: A room of size group group with facing
#               value facing is drawn at position
#               (x, y) with glyph glyph.
#

{{
function mapAddRoomDirection (e, x, y, group, facing,
                              is_room_attached, glyph, door_type)
  assert(x > 0, "The x-coordinate for the room must be > 0")
  assert(y > 0, "The y-coordinate for the room must be > 0")
  assert(x < MAP_SIZE - 1,
         "The x-coordinate for the room must be < MAP_SIZE - 1")
  assert(y < MAP_SIZE - 1,
         "The y-coordinate for the room must be < MAP_SIZE - 1")
  assert(group < ROOM_GROUP_COUNT, "Invalid group " .. group)
  assert(facing < FACING_VALID_COUNT, "Invalid facing direction " .. facing)
  assert(door_type < DOOR_TYPE_COUNT, "Invalid door type " .. door_type)
  assert(facing < FACING_DIRECTION_COUNT,
         "Invalid facing direction for direction room " .. facing)
  assert(door_type ~= DOOR_TYPE_CITY,
         "Invalid door type for direction room " .. door_type)

  local room_size = A_ROOM_SIZE[group]

  -- this is the main part of the room
  e.fill_area{x1=x, y1=y,
              x2=(x + room_size - 1), y2=(y + room_size - 1),
              fill=glyph}

  if door_type == DOOR_TYPE_SPIN then
    mapAddRoomDoor(e, x, y, group, facing, 'B', true)
  else
    -- DOOR_TYPE_FACING
    -- DOOR_TYPE_DEAD_END
    mapAddRoomDoor(e, x, y, group, facing, glyph, false)
  end
end
}}

{{
function mapAddRoomCorner (e, x, y, group, facing,
                           is_room_attached, glyph, door_type)

  assert(x > 0, "The x-coordinate for the room must be > 0")
  assert(y > 0, "The y-coordinate for the room must be > 0")
  assert(x < MAP_SIZE - 1,
         "The x-coordinate for the room must be < MAP_SIZE - 1")
  assert(y < MAP_SIZE - 1,
         "The y-coordinate for the room must be < MAP_SIZE - 1")
  assert(group < ROOM_GROUP_COUNT, "Invalid group " .. group)
  assert(facing < FACING_VALID_COUNT, "Invalid facing direction " .. facing)
  assert(door_type < DOOR_TYPE_COUNT, "Invalid door type " .. door_type)
  assert(facing >= FACING_CORNER_XM_YM and facing <= FACING_CORNER_XP_YP,
         "Invalid facing direction for corner room " .. facing)
  assert(door_type ~= DOOR_TYPE_CITY,
         "Invalid door type for corner room " .. door_type)

  local room_size = A_ROOM_SIZE[group]

  -- this is the main part of the room
  e.fill_area{x1=x, y1=y,
              x2=(x + room_size - 1), y2=(y + room_size - 1),
              fill=glyph}

  -- find the sides for the main and possible side doors
  local door_main
  local door_side
  if facing == FACING_CORNER_XM_YM then
    door_main = FACING_X_MINUS
    door_side = FACING_Y_MINUS
  elseif facing == FACING_CORNER_XM_YP then
    door_main = FACING_X_MINUS
    door_side = FACING_Y_PLUS
  elseif facing == FACING_CORNER_XP_YM then
    door_main = FACING_X_PLUS
    door_side = FACING_Y_MINUS
  elseif facing == FACING_CORNER_XP_YP then
    door_main = FACING_X_PLUS
    door_side = FACING_Y_PLUS
  end

  if crawl.random2(2) < 1 then
    local temp = door_main
    door_main = door_side
    door_side = temp
  end

  if door_type == DOOR_TYPE_SPIN then
    mapAddRoomDoor(e, x, y, group, door_main, 'B', true)
    if crawl.random2(100) < CORNER_ROOM_SIDE_DOOR_PERCENT then
      mapAddRoomDoor(e, x, y, group, door_side, 'B', true)
    end
  elseif door_type == DOOR_TYPE_FACING then
    mapAddRoomDoor(e, x, y, group, door_main, glyph, false)
    if crawl.random2(100) < CORNER_ROOM_SIDE_DOOR_PERCENT then
      mapAddRoomDoor(e, x, y, group, door_side, 'B', true)
    end
  else
    -- DOOR_TYPE_DEAD_END
    mapAddRoomDoor(e, x, y, group, door_main, glyph, false)
  end
end
}}

{{
function mapAddRoomCity (e, x, y, group, facing,
                         is_room_attached, glyph, door_type)

  assert(x > 0, "The x-coordinate for the room must be > 0")
  assert(y > 0, "The y-coordinate for the room must be > 0")
  assert(x < MAP_SIZE - 1,
         "The x-coordinate for the room must be < MAP_SIZE - 1")
  assert(y < MAP_SIZE - 1,
         "The y-coordinate for the room must be < MAP_SIZE - 1")
  assert(group < ROOM_GROUP_COUNT, "Invalid group " .. group)
  assert(facing < FACING_VALID_COUNT, "Invalid facing direction " .. facing)
  assert(door_type < DOOR_TYPE_COUNT, "Invalid door type " .. door_type)
  assert(facing == FACING_CITY,
         "Invalid facing direction for city room " .. facing)

  local room_size = A_ROOM_SIZE[group]

  -- this is the main part of the room
  e.fill_area{x1=x, y1=y,
              x2=(x + room_size - 1), y2=(y + room_size - 1),
              fill=glyph}

  local door_facing = crawl.random2(FACING_DIRECTION_COUNT)

  if door_type == DOOR_TYPE_SPIN then
    mapAddRoomDoor(e, x, y, group, door_facing, 'B', true)
    for i = 0, FACING_DIRECTION_COUNT - 1 do
      if door_facing ~= i and
         crawl.random2(100) < CITY_ROOM_SIDE_DOOR_PERCENT then
        mapAddRoomDoor(e, x, y, group, i, 'B', true)
      end
    end

  elseif door_type == DOOR_TYPE_FACING then
    mapAddRoomDoor(e, x, y, group, door_facing, glyph, false)
    for i = 0, FACING_DIRECTION_COUNT - 1 do
      if door_facing ~= i and
         crawl.random2(100) < CITY_ROOM_SIDE_DOOR_PERCENT then
        mapAddRoomDoor(e, x, y, group, i, 'B', true)
      end
    end

  elseif door_type == DOOR_TYPE_DEAD_END then
    mapAddRoomDoor(e, x, y, group, door_facing, glyph, false)

  else
    -- DOOR_TYPE_CITY
    e.fill_area{x1=(x - 1), y1=(y - 1),
                x2=(x + room_size), y2=(y + room_size),
                fill=glyph}
  end
end
}}

{{
function mapAddRoomNone (e, x, y, group, facing,
                         is_room_attached, glyph, door_type)
  assert(x > 0, "The x-coordinate for the room must be > 0")
  assert(y > 0, "The y-coordinate for the room must be > 0")
  assert(x < MAP_SIZE - 1,
         "The x-coordinate for the room must be < MAP_SIZE - 1")
  assert(y < MAP_SIZE - 1,
         "The y-coordinate for the room must be < MAP_SIZE - 1")
  assert(group < ROOM_GROUP_COUNT, "Invalid group " .. group)
  assert(facing < FACING_VALID_COUNT, "Invalid facing direction " .. facing)
  assert(door_type < DOOR_TYPE_COUNT, "Invalid door type " .. door_type)
  assert(facing == FACING_NONE,
         "Invalid facing direction for none room " .. facing)
  assert(door_type == DOOR_TYPE_SPIN,
         "Invalid door type for none room " .. door_type)

  local room_size = A_ROOM_SIZE[group]

  -- this is the main part of the room
  e.fill_area{x1=x, y1=y,
              x2=(x + room_size - 1), y2=(y + room_size - 1),
              fill=glyph}
end
}}

#
#  mapAddRoomDoor
#
#  Purpose: To fill add a door of with the specified glyph for
#           a room of the specified group at the specified
#           position with the specified facing direction.  The
#           position is taken to be the minimum x/y-coordinate
#           of the room proper.
#  Parameter(s):
#      <1> e: The global enviroment
#      <2> x
#      <3> y: The minimum x/y coordinate
#      <4> group: The size group for the conceptual room
#      <5> facing: The facing value for the door
#      <6> glyph: The glyph to fill the door with
#      <7> add_subvault: Whether to use a subvault for this
#                        door
#  Preconditon(s):
#      <1> x > 0
#      <2> y > 0
#      <3> x < MAP_SIZE - 1
#      <4> y < MAP_SIZE - 1
#      <5> group < ROOM_GROUP_COUNT
#      <6> facing < FACING_DIRECTION_COUNT
#  Returns: N/A
#  Side Effect: A door for side facing of a room of size group
#               group is drawn at position (x, y)
#               with glyph glyph.  If add_subvault is true, the
#               door is then replaced by a subvault.  It is the
#               responsiblility of the calling function to
#               ensure that there are no other glyph glyphs on
#               the map.
#

{{
function mapAddRoomDoor (e, x, y, group, facing, glyph, add_subvault)
  assert(x > 0, "The x-coordinate for the room must be > 0")
  assert(y > 0, "The y-coordinate for the room must be > 0")
  assert(x < MAP_SIZE - 1,
         "The x-coordinate for the room must be < MAP_SIZE - 1")
  assert(y < MAP_SIZE - 1,
         "The y-coordinate for the room must be < MAP_SIZE - 1")
  assert(group < ROOM_GROUP_COUNT, "Invalid group " .. group)
  assert(facing < FACING_VALID_COUNT,
         "Invalid facing direction " .. facing)

  local room_size = A_ROOM_SIZE[group]
  local door_start = math.floor((room_size - A_DOOR_SIZE[group]) / 2)
  local door_end = door_start + A_DOOR_SIZE[group] - 1

  if facing == FACING_X_MINUS then
    e.fill_area{x1=(x - 1), y1=(y + door_start),
                x2=(x - 1), y2=(y + door_end),
                fill=glyph}
  elseif facing == FACING_X_PLUS then
    e.fill_area{x1=(x + room_size), y1=(y + door_start),
                x2=(x + room_size), y2=(y + door_end),
                fill=glyph}
  elseif facing == FACING_Y_MINUS then
    e.fill_area{x1=(x + door_start), y1=(y - 1),
                x2=(x + door_end),   y2=(y - 1),
                fill=glyph}
  else
    -- FACING_Y_PLUS
    e.fill_area{x1=(x + door_start), y1=(y + room_size),
                x2=(x + door_end),   y2=(y + room_size),
                fill=glyph}
  end

  if add_subvault then
    if group > ROOM_GROUP_CLOSET then
      e.subvault(glyph .. " : vaults_door_" .. room_size)
      -- just to be safe...
      e.subst(glyph .. " : x")
    else
      e.subst(glyph .. " = +")
    end
  end
end
}}

#
#  mapAddRoomHallway
#
#  Purpose: To add a hallway at the specified position with
#           the specified facing direction and connected on the
#           specified sides.  The size of the hallway is the
#           size of a room of the specified group and the
#           position is taken to be the minimum x/y-coordinate
#           of where the room would have been.
#  Parameter(s):
#      <1> e: The global enviroment
#      <2> x
#      <3> y: The minimum x/y coordinate
#      <4> group: The size group for the hallway
#      <5> facing: The facing value for the hallway
#      <6> glyph: The glyph to fill the hallway with
#      <7> connected_x_minus
#      <8> connected_x_plus
#      <9> connected_y_minus
#      <10>connected_y_plus: Whether the hallway connects to
#                            another room on the indicated
#                            side
#  Preconditon(s):
#      <1> x > 0
#      <2> y > 0
#      <3> x < MAP_SIZE - 1
#      <4> y < MAP_SIZE - 1
#      <5> group < ROOM_GROUP_COUNT
#      <6> facing < FACING_DIRECTION_COUNT ||
#          facing == FACING_NONE
#      <7> facing != FACING_X_MINUS || connected_x_minus
#      <8> facing != FACING_X_PLUS  || connected_x_plus
#      <9> facing != FACING_Y_MINUS || connected_y_minus
#      <10>facing != FACING_Y_PLUS  || connected_y_plus
#  Returns: N/A
#  Side Effect: A hallway is added with the size of a
#               room of size group group at position (x, y).
#               The hallway is connected based the
#               connected_??? parameters and is has facing
#               value facing.  The hallway has the width of
#               the room doors and is filled with glyph
#               glyph.
#

{{
function mapAddRoomHallway (e, x, y, group, facing, glyph,
                            connected_x_minus, connected_x_plus,
                            connected_y_minus, connected_y_plus)
  assert(x > 0, "The x-coordinate for the room must be > 0")
  assert(y > 0, "The y-coordinate for the room must be > 0")
  assert(x < MAP_SIZE - 1,
         "The x-coordinate for the room must be < MAP_SIZE - 1")
  assert(y < MAP_SIZE - 1,
         "The y-coordinate for the room must be < MAP_SIZE - 1")
  assert(group < ROOM_GROUP_COUNT, "Invalid group " .. group)
  assert(facing < FACING_DIRECTION_COUNT or facing == FACING_NONE,
         "Invalid facing direction " .. facing)
  assert(facing ~= FACING_X_MINUS or connected_x_minus,
         "Hallway cannot face to side not connected on: X-")
  assert(facing ~= FACING_X_PLUS  or connected_x_plus,
         "Hallway cannot face to side not connected on: X+")
  assert(facing ~= FACING_Y_MINUS or connected_y_minus,
         "Hallway cannot face to side not connected on: Y-")
  assert(facing ~= FACING_Y_PLUS  or connected_y_plus,
         "Hallway cannot face to side not connected on: Y+")

  local room_size = A_ROOM_SIZE[group]
  local door_size = A_DOOR_SIZE[group]
  local door_offset = math.floor((room_size - door_size) / 2)
  local door_far_offset = door_offset + door_size

  -- center
  e.fill_area{x1=(x + door_offset),
              y1=(y + door_offset),
              x2=(x + door_far_offset - 1),
              y2=(y + door_far_offset - 1),
              fill=glyph}

  -- arms
  if connected_x_minus then
    e.fill_area{x1=x,
                y1=(y + door_offset),
                x2=(x + door_offset - 1),
                y2=(y + door_far_offset - 1),
                fill=glyph}
  end
  if connected_x_plus then
    e.fill_area{x1=(x + door_far_offset),
                y1=(y + door_offset),
                x2=(x + room_size - 1),
                y2=(y + door_far_offset - 1),
                fill=glyph}
  end
  if connected_y_minus then
    e.fill_area{x1=(x + door_offset),
                y1=y,
                x2=(x + door_far_offset - 1),
                y2=(y + door_offset - 1),
                fill=glyph}
  end
  if connected_y_plus then
    e.fill_area{x1=(x + door_offset),
                y1=(y + door_far_offset),
                x2=(x + door_far_offset - 1),
                y2=(y + room_size - 1),
                fill=glyph}
  end

  -- where door would be
  if facing == FACING_X_MINUS then
    mapAddRoomDoor(e, x, y, group, FACING_X_MINUS, glyph, false)
  elseif facing == FACING_X_PLUS then
    mapAddRoomDoor(e, x, y, group, FACING_X_PLUS,  glyph, false)
  elseif facing == FACING_Y_MINUS then
    mapAddRoomDoor(e, x, y, group, FACING_Y_MINUS, glyph, false)
  elseif facing == FACING_Y_PLUS then
    mapAddRoomDoor(e, x, y, group, FACING_Y_PLUS,  glyph, false)
  end
end
}}

#
#  isSubvaultForRoom
#
#  Purpose: To determine if there is a room of the specified
#           size group and with the specified door type,
#           content, and facing value.
#  Parameter(s):
#      <1> group: The size group
#      <2> door_type: The door type
#      <3> content: The room content type
#      <4> facing: The facing value for the room
#  Preconditon(s):
#      <1> group < ROOM_GROUP_COUNT
#      <2> door_type < DOOR_TYPE_COUNT
#      <3> content < CONTENT_VALID_COUNT
#      <4> facing < FACING_COUNT
#  Returns: Whether there are any subvaults for a room with
#           size group group, door type door_type, and content
#           type content.
#  Side Effect: N/A
#

{{
function isSubvaultForRoom (group, door_type, content, facing)
  assert(group < ROOM_GROUP_COUNT, "Invalid group " .. group)
  assert(door_type < DOOR_TYPE_COUNT,
         "Invalid door type " .. door_type)
  assert(content < CONTENT_VALID_COUNT,
         "Invalid content type " .. content)
  assert(facing < FACING_COUNT,
         "Invalid facing value " .. content)

  if dgn.map_by_tag(getSubvaultTag(group, door_type, content, facing)) then
    return true
  else
    return false
  end
end
}}

#
#  getSubvaultTag
#
#  Purpose: To determine the subvault tag to use for a room of
#           the specified size group and with the specified
#           door type and the specifed content.
#  Parameter(s):
#      <1> group: The size group
#      <2> door_type: The door type
#      <3> content: The room content type
#      <4> facing: The facing value for the room
#  Preconditon(s):
#      <1> group < ROOM_GROUP_COUNT
#      <2> door_type < DOOR_TYPE_COUNT
#      <3> content < CONTENT_VALID_COUNT
#      <4> facing < FACING_COUNT
#  Returns: The tag for a subvault of size group group, door
#           type door_type, and content type content.
#  Side Effect: N/A
#

{{
function getSubvaultTag (group, door_type, content, facing)
  assert(group < ROOM_GROUP_COUNT, "Invalid group " .. group)
  assert(door_type < DOOR_TYPE_COUNT,
         "Invalid door type " .. door_type)
  assert(content < CONTENT_VALID_COUNT,
         "Invalid content type " .. content)
  assert(facing < FACING_COUNT,
         "Invalid facing value " .. content)

  if (content == CONTENT_STAIRS_DOWN_1A or
      content == CONTENT_STAIRS_DOWN_1B or
      content == CONTENT_STAIRS_DOWN_1C) and
     facing == FACING_NONE then

    -- this is a "secret" room only accessible from below
    return "vaults_room_" .. A_ROOM_SIZE[group] ..
           "_" .. A_DOOR_TYPE_NAME[door_type] ..
           "_" .. CONTENT_NAME_SECRET
  else
    -- this is a normal room
    return "vaults_room_" .. A_ROOM_SIZE[group] ..
           "_" .. A_DOOR_TYPE_NAME[door_type] ..
           "_" .. A_CONTENT_NAME[content]
  end
end
}}




################################################################################
#  Layout Generation Functions
#
#  These are the functions that generate the layouts.  Each of
#    these is called by at least one layout.  Some of these are
#    called by more than one layout, with differant parameters.
#



########
#
#  layoutCity
#
#  Purpose: To generate a map with the rooms as isolated
#           buildings placed in a grid on an otherwise-open
#           map.
#  Parameter(s):
#      <1> e: The global enviroment
#      <2> depth: The depth of the map within the branch
#      <3> size_group: The size group for the rooms
#      <4> a_content_frequency: The frequency of differant room
#                               content types
#      <5> content_solid_frequency: The frequency of a room
#                                   being filled with solid
#                                   wall
#      <6> a_entries: The content types for any branch or
#                     portal entries to add to the map
#  Preconditon(s):
#      <1> size_group != ROOM_GROUP_CLOSET
#      <2> size_group < ROOM_GROUP_COUNT
#      <3> a_content_frequency != NULL
#      <4> a_entries != NULL
#  Returns: N/A
#  Side Effect: A map with rooms layed out in a grid and
#               seperated by hallways is generated and printed
#               to standard output.  The rooms are of size
#               group size_group with the content types
#               specified by a_content_frequency.  The map
#               generated is appropriate for depth depth.
#

{{
function layoutCity (e,
                     depth,
                     size_group,
                     a_content_frequency,
                     content_solid_frequency,
                     a_entries)

  assert(size_group ~= ROOM_GROUP_CLOSET,
         "Cannot generate a city with closet rooms")
  assert(size_group < ROOM_GROUP_COUNT,
         "Invalid room size group: " .. size_group)
  assert(a_content_frequency ~= nil,
         "a_content_frequency cannot == nil")
  assert(a_entries ~= nil, "a_entries cannot == nil")

  --
  --  1.  Hallways
  --
  --  Choosing the hallway size makes it possible to
  --    calculate how many rooms will placed
  --
  --  The room layout is: wall, hallway, [room, hallway],
  --    wall.  This means that a map with no rooms would
  --    have a size of the hallway width + 2.
  --

  local size_map_maximum
  local size_room
  local size_hallway
  local size_hallway_minimum
  local size_room_effective

  local size_for_rooms_maximum
  local rooms_across
  local size_map_real

  size_room = A_ROOM_SIZE[size_group]
  size_map_maximum = getMaximumMapSize(depth)
  size_hallway = getRandomHallwaySize(depth)
  size_hallway_minimum = getMinimumHallwaySize(depth)

  -- we need a map big enough to contain 3 by 3 = 9 rooms
  local size_map_minimum = size_hallway_minimum * 4 + size_room * 3 + 8
  if size_map_maximum < size_map_minimum then
    size_map_maximum = size_map_minimum
  end

  -- we need at least 3 by 3 = 9 rooms to have enough for stairs
  if size_hallway * 4 + size_room * 3 + 8 > size_map_maximum then
    local available_size = size_map_maximum - (size_room * 3 + 8)
    size_hallway = math.floor(available_size / 4)
  end

  size_room_effective = size_room + size_hallway + 2
  size_for_rooms_maximum = size_map_maximum - (size_hallway + 2)
  rooms_across = math.floor(size_for_rooms_maximum / size_room_effective)

  size_map_real = 2 + size_hallway + rooms_across * size_room_effective

  --
  --  2. Assign the rooms to positions
  --
  --  We disconnect 2 rooms so that we can have boxed
  --    stairs.  If stairs are not placed in them, they
  --    will be reconnected later.
  --

  local room_count_total = rooms_across * rooms_across
  local a_rooms = {}

  for r = 0, room_count_total - 1 do
    a_rooms[r] = createDefaultRoom(size_group)
  end

  -- disconnect 2 rooms to put stairs in
  for i = 0, 1 do
    local index = crawl.random2(room_count_total)

    while a_rooms[index].m_connection ~= CONNECTION_NORMAL do
      index = crawl.random2(room_count_total)
    end

    a_rooms[index].m_connection = CONNECTION_NONE
  end

  --
  --  3. Assign room contents
  --

  calculateContentStairs(a_rooms, room_count_total,
                         depth)
  calculateContentBranchPortal(a_rooms, room_count_total,
                               a_entries)
  calculateContentSerialVault(a_rooms, room_count_total)
  calculateContentSolid(a_rooms, room_count_total,
                        a_content_frequency,
                        content_solid_frequency)
  calculateContentProbability(a_rooms, room_count_total,
                              a_content_frequency)
  connectDisconnectedRooms(a_rooms, room_count_total)

  --
  --  4. Print out layout statistics
  --

  if PRINT_LAYOUT_STATISTICS then
    crawl.mpr("Layout Statistics (City)\r")
    crawl.mpr("  Depth: " .. depth)
    crawl.mpr("  Map size: " .. size_map_real .. "\r")
    crawl.mpr("  Room group: " .. size_group .. "\r")
    crawl.mpr("  Base room size: " .. size_room .. "\r")
    crawl.mpr("  Room size including walls and hallway: " ..
              size_room_effective .. "\r")
    crawl.mpr("  Total rooms: " .. room_count_total .. " (" ..
              rooms_across .. " by " .. rooms_across .. ")\r")
    crawl.mpr("  Hallway size: " .. size_hallway ..
              " (min " .. getMinimumHallwaySize(depth) .. ")\r")
  end

  --
  --  5. Generate map
  --

  local max_open_pos = size_map_real - 2
  e.fill_area{x1=1, y1=1, x2=max_open_pos, y2=max_open_pos, fill='.'}

  for r = 0, room_count_total - 1 do
    local y_base = math.floor(r / rooms_across)
    local x_base = math.floor(r % rooms_across)

    local room_size = A_ROOM_SIZE[size_group]
    local content = a_rooms[r].m_content

    local y = 2 + size_hallway + y_base * size_room_effective
    local x = 2 + size_hallway + x_base * size_room_effective

    local min_x = x - 1
    local min_y = y - 1
    local max_x = x + room_size
    local max_y = y + room_size
    e.fill_area{x1=min_x, y1=min_y, x2=max_x, y2=max_y, fill='x'}

    if a_rooms[r].m_connection == CONNECTION_NONE then
      mapAddRoom(e, x, y, size_group, FACING_NONE, false, content)
    else
      mapAddRoom(e, x, y, size_group, FACING_CITY, false, content)
    end
  end
end
}}



########
#
#  layoutChaoticCity
#
#  Purpose: To generate a map with the rooms rooms as isolated
#           buildings placed randomly on an otherwise-open map.
#  Parameter(s):
#      <1> e: The global enviroment
#      <2> depth: The depth of the map within the branch
#      <3> a_group_frequency: The frequency of differant room
#                             groups
#      <4> a_content_frequency: The frequency of differant room
#                               content types
#      <5> content_solid_frequency: The frequency of a room
#                                   being filled with solid
#                                   wall
#      <6> a_entries: The content types for any branch or portal
#                     entries to add to the map
#  Preconditon(s):
#      <1> a_group_frequency != NULL
#      <2> a_group_frequency[ROOM_GROUP_TOTAL_FREQUENCY] > 0
#      <3> a_content_frequency != NULL
#      <4> a_entries != NULL
#  Returns: N/A
#  Side Effect: A map with rooms scattered across an
#               otherwise-open map is generated and printed to
#               standard output.  The room sizes and contents
#               are respectively based on a_group_frequency and
#               a_content_frequency in a manner appropriate for
#               depth depth.  If the layout generator cannot
#               fit enough rooms of the specified size groups
#               on the map, some closest (1x1 rooms) map be
#               added.
#

{{
function layoutChaoticCity (e,
                            depth,
                            a_group_frequency,
                            a_content_frequency,
                            content_solid_frequency,
                            a_entries)

  assert(a_group_frequency ~= nil,
         "a_group_frequency cannot == nil")
  assert(a_group_frequency.total > 0,
         "total frequency must be > 0")
  assert(a_content_frequency ~= nil,
         "a_content_frequency cannot == nil")
  assert(a_entries ~= nil, "a_entries cannot == nil")

  --
  --  1.  Hallway and Map mize
  --
  --  We start by choosing the hallway size and the map
  --    size.
  --

  local size_map = getMaximumMapSize(depth)
  local size_hallway = getMinimumHallwaySize(depth)

  --
  --  2. Create rooms
  --
  --  We will try to create a lot more rooms then we end
  --    up with.  Rooms that overlap an existing room will
  --    be marked with the m_is_dummy_wall flag and will
  --    not be placed.
  --
  --  After we have found the working rooms, we shift them
  --    to the front of the array.
  --

  local total_map_area = size_map * size_map

  local room_count_attempts =
                math.floor(total_map_area * CHAOTIC_CITY_PLACE_ATTEMPTS_FACTOR)
  local a_rooms = {}

  local position_min = 2 + size_hallway
  local position_max = size_map - (2 + size_hallway)
  local room_count_placed = calculateRoomsForChaoticCity(
            position_min, position_min,
            position_max, position_max,
            size_hallway,
            a_group_frequency,
            a_rooms,
            0,
            CHAOTIC_CITY_MINIMUM_ROOMS_PLACED,
            room_count_attempts)

  -- disconnect 2 rooms to put stairs in
  for i = 0, 1 do
    local index = crawl.random2(room_count_placed)

    while a_rooms[index].m_connection ~= CONNECTION_NORMAL or
          a_rooms[index].m_group == ROOM_GROUP_CLOSET do
      index = crawl.random2(room_count_placed)
    end

    a_rooms[index].m_connection = CONNECTION_NONE
  end

  --
  --  3. Assign room contents
  --

  calculateContentStairs(a_rooms, room_count_placed,
                         depth)
  calculateContentBranchPortal(a_rooms, room_count_placed,
                               a_entries)
  calculateContentSerialVault(a_rooms, room_count_placed)
  calculateContentSolid(a_rooms, room_count_placed,
                        a_content_frequency,
                        content_solid_frequency)
  calculateContentProbability(a_rooms, room_count_placed,
                              a_content_frequency)
  connectDisconnectedRooms(a_rooms, room_count_placed)

  --
  --  4. Print out layout statistics
  --

  if PRINT_LAYOUT_STATISTICS then
    crawl.mpr("Layout Statistics (Chaotic City)")
    crawl.mpr("  Depth: " .. depth)
    crawl.mpr("  Map size: " .. size_map)
    crawl.mpr("  Largest group: " .. getLargestGroup(a_group_frequency))
    local line = "  Frequencies:"
    for g = 0, ROOM_GROUP_COUNT - 1 do
      line = line .. "    " .. g .. ": " .. a_group_frequency[g]
    end
    line = line .. "    = " .. a_group_frequency.total
    crawl.mpr(line)
    crawl.mpr("  Total rooms attempted: " .. room_count_attempts)
    crawl.mpr("  Total rooms placed: " .. room_count_placed)
    crawl.mpr("  Rooms placed: ")
    for r = 0, room_count_placed - 1 do
      if a_rooms[r].m_is_dummy_wall then
        crawl.mpr("X")
      else
        crawl.mpr(a_rooms[r].m_group)
      end
    end
    crawl.mpr("  Hallway size: ")
  end

  --
  --  5. Generate map
  --

  e.fill_area{x1=1, y1=1,
              x2=(size_map - 2), y2=(size_map - 2),
              fill='_'}

  for r = 0, room_count_placed - 1 do
    local group = a_rooms[r].m_group
    local room_size = A_ROOM_SIZE[group]
    local content = a_rooms[r].m_content

    local x = a_rooms[r].m_x
    local y = a_rooms[r].m_y

    local min_x = x - 1
    local min_y = y - 1
    local max_x = x + room_size
    local max_y = y + room_size
    e.fill_area{x1=min_x, y1=min_y, x2=max_x, y2=max_y, fill='x'}
    if a_rooms[r].m_connection == CONNECTION_NONE then
      mapAddRoom(e, x, y, group, FACING_NONE, false, content)
    else
      mapAddRoom(e, x, y, group, FACING_CITY, false, content)
    end
  end
end
}}

########
#
#  layoutMaze
#
#  Purpose: To generate a map with the rooms connected directly
#           to each other in a maze.  There are no hallways in
#           the maze.  The stairs are placed together in two of
#           the four corners.
#  Parameter(s):
#      <1> e: The global enviroment
#      <2> depth: The depth of the map within the branch
#      <3> size_group: The size group for the rooms
#      <4> a_content_frequency: The frequency of differant room
#                               contents type
#      <5> content_solid_frequency: The frequency of a room
#                                   being filled with solid
#                                   wall
#      <6> branch_factor: How likely the path through the maze
#                         is to branch
#      <7> extra_connection_percent: The percent chance of
#                                    adding a connection
#                                    between suitable adjacent
#                                    rooms
#      <8> a_entries: The content types for any branch or portal
#                   entries to add to the map
#  Preconditon(s):
#      <1> size_group != ROOM_GROUP_CLOSET
#      <2> size_group < ROOM_GROUP_COUNT
#      <3> a_content_frequency != NULL
#      <4> branch_factor <= 100
#      <5> extra_connection_percent <= 100
#      <6> a_entries != NULL
#  Returns: N/A
#  Side Effect: A map with rooms layed out in a maze is
#               generated and printed to standard output.  The
#               rooms are of size group size_group with the
#               content types specified by a_content_frequency
#               and content_solid_frequency.  The map generated
#               is appropriate for depth depth and has
#               branch_factor branchiness.  A higher
#               branch_factor will make the path through the
#               map branch more.
#

{{
function layoutMaze (e,
                     depth,
                     size_group,
                     a_content_frequency,
                     content_solid_frequency,
                     branch_factor,
                     extra_connection_percent,
                     a_entries)

  assert(size_group ~= ROOM_GROUP_CLOSET,
         "Cannot generate a city with closet rooms")
  assert(size_group < ROOM_GROUP_COUNT,
         "Invalid room size group: " .. size_group)
  assert(a_content_frequency ~= nil,
         "a_content_frequency cannot == nil")
  assert(branch_factor >= 0, "branch_factor must be >= 0")
  assert(branch_factor <= 100, "branch_factor must be >= 100")
  assert(extra_connection_percent <= 100,
         "extra_connection_percent must be >= 100")
  assert(a_entries ~= nil, "a_entries cannot == nil")

  --
  --  1.  Map Size
  --
  --  We start by calculating how big of a map we want and
  --    how many rooms will fit in it.  The map layout is:
  --    wall, [room, wall], so we will need to allow for
  --    walls when calculating sizes.
  --
  --  There have to be at least 2 rooms across so that we
  --    can place the stairs.  There would 3 walls for
  --    this, so that map must be at least
  --    room_size * 2 + 3 across.  There is no fallback
  --    approach if this fails.
  --

  local size_map_maximum
  local size_room

  local rooms_across
  local size_map_real

  size_room = A_ROOM_SIZE[size_group]
  size_map_maximum = getMaximumMapSize(depth)

  -- we need at least 2 by 2 = 4 rooms to have enough for stairs
  rooms_across = math.floor((size_map_maximum - 1) / (size_room + 1))
  size_map_real = 1 + rooms_across * (size_room + 1)

  --
  --  3. Create the room maze
  --
  --  We will be create the rooms and their connections in
  --    parallel.  They are in two differant arrays.
  --
  --  I think this is a variantion on the Scarab of Ra
  --    alogorithm.
  --
  --  We start by picking a random spot and put it on our
  --    stack.  Then, we connect it to an unconnected
  --    neighbouring room at random, put that room on the
  --    stack, and go there.  If we cannot connect a room,
  --    we take it off the stack and start trying to
  --    connect stuff to the room below.  When we run out
  --    of stack, all the rooms will be connected.
  --
  --  Edit: Always picking starting from the
  --        most-recently-added room tends to produce
  --        a single long paths with only a few branches.
  --        To avoid this, I occasionally swap (in stack
  --        position) the new room for a room that is
  --        already in the stack.
  --

  local room_count_total = rooms_across * rooms_across
  local a_rooms = {}

  for r = 0, room_count_total - 1 do
    a_rooms[r] = createDefaultRoom(size_group)
  end

  local stack = {}
  stack.count = 0
  local start_room

  start_room = crawl.random2(room_count_total)
  a_rooms[start_room].m_facing_direction = FACING_NONE
  stack[stack.count] = start_room
  stack.count = 1

  while stack.count > 0 do
    local current = stack[stack.count - 1]

    --
    --  These are the directions we can choose.  We
    --    actually store the facing ditrection we
    --    will apply to room we connect, not the
    --    direction that room is from here.
    --
    local choice_count = 0
    local a_index = {}
    local a_direction = {}

    -- find the available directions to connect
    if current >= 1 and
       current % rooms_across >= 1 and
       a_rooms[current - 1].m_facing_direction ==
                                  FACING_UNASSIGNED then

      -- X-
      a_index[choice_count] = current - 1
      a_direction[choice_count] = FACING_X_PLUS
      choice_count = choice_count + 1
    end

    if current < room_count_total - 1 and
       current % rooms_across < rooms_across - 1 and
       a_rooms[current + 1].m_facing_direction ==
                                  FACING_UNASSIGNED then

      -- X+
      a_index[choice_count] = current + 1
      a_direction[choice_count] = FACING_X_MINUS
      choice_count = choice_count + 1
    end

    if current >= rooms_across and
       a_rooms[current - rooms_across].m_facing_direction ==
                                 FACING_UNASSIGNED then

      -- Y-
      a_index[choice_count] = current - rooms_across
      a_direction[choice_count] = FACING_Y_PLUS
      choice_count = choice_count + 1
    end

    if current < room_count_total - rooms_across and
       a_rooms[current + rooms_across].m_facing_direction ==
                                 FACING_UNASSIGNED then

      -- Y+
      a_index[choice_count] = current + rooms_across
      a_direction[choice_count] = FACING_Y_MINUS
      choice_count = choice_count + 1
    end

    if choice_count == 0 then
      -- nothing to do here, remove this node
      stack.count = stack.count - 1
    else
      -- attach a random direction

      local chosen = crawl.random2(choice_count)
      local chosen_index = a_index[chosen]

      a_rooms[chosen_index].m_facing_direction = a_direction[chosen]

      if crawl.random2(100) < branch_factor then
        local other_stack_index = crawl.random2(stack.count)
        stack[stack.count] = stack[other_stack_index]
        stack[other_stack_index] = chosen_index
      else
        stack[stack.count] = chosen_index
      end
      stack.count = stack.count + 1

      a_rooms[chosen_index].m_connected_to = current
      a_rooms[current].m_attached_count = a_rooms[current].m_attached_count + 1
      -- the above line is only 79 characters - yay!
    end
  end

  --
  --  4. Assign room contents
  --
  --  The stairs are always placed together in corners.
  --    There will be three up staors ain one corner and
  --    3 down staors in another.
  --

  local up_corner = crawl.random2(4)
  local up_index
  if up_corner == 0 then
    up_index = 0
  elseif up_corner == 1 then
    up_index = rooms_across - 1
  elseif up_corner == 2 then
    up_index = room_count_total - rooms_across
  else
    -- up_corner == 3 then
    up_index = room_count_total - 1
  end
  a_rooms[up_index].m_content = CONTENT_STAIRS_UP_3

  local down_corner = crawl.random2(4)
  while down_corner == up_corner do
    down_corner = crawl.random2(4)
  end
  local down_index
  if down_corner == 0 then
    down_index = 0
  elseif down_corner == 1 then
    down_index = rooms_across - 1
  elseif down_corner == 2 then
    down_index = room_count_total - rooms_across
  else
    -- down_corner == 3 then
    down_index = room_count_total - 1
  end
  a_rooms[down_index].m_content = CONTENT_STAIRS_DOWN_3

  -- stairs were just calculated
  calculateContentBranchPortal(a_rooms, room_count_total,
                               a_entries)
  calculateContentSerialVault(a_rooms, room_count_total)
  calculateContentSolid(a_rooms, room_count_total,
                        a_content_frequency,
                        content_solid_frequency)
  calculateContentProbability(a_rooms, room_count_total,
                              a_content_frequency)
  makeAllDeadEndHallwaysSolid(a_rooms, room_count_total)
  -- no chance of disconnected rooms

  -- change the start room if it is a dead-end hallway
  if a_rooms[start_room].m_content == CONTENT_HALLWAY and
     a_rooms[start_room].m_attached_count == 1 then

    a_rooms[start_room].m_content = CONTENT_EMPTY
  end

  --
  --  5. Print out layout statistics
  --

  if PRINT_LAYOUT_STATISTICS then
    crawl.mpr("Layout Statistics (Maze)\r")
    crawl.mpr("  Depth: "      .. depth .. "\r")
    crawl.mpr("  Map size: "   .. size_map_real .. "\r")
    crawl.mpr("  Room group: " .. size_group .. "\r")
    crawl.mpr("  Room size: "  .. size_room .. "\r")
    crawl.mpr("  Total rooms: "  .. room_count_total  .. " (" ..
              rooms_across .. " by " .. rooms_across ..")")
  end

  --
  --  6. Generate map
  --

  for r = 0, room_count_total - 1 do
    local y_base = math.floor(r / rooms_across)
    local x_base =            r % rooms_across

    local y = 1 + y_base * (size_room + 1)
    local x = 1 + x_base * (size_room + 1)

    local content = a_rooms[r].m_content
    local facing  = a_rooms[r].m_facing_direction

    if content == CONTENT_HALLWAY then
      local needs_door = true

      local connected_x_minus = false
      local connected_x_plus  = false
      local connected_y_minus = false
      local connected_y_plus  = false

      -- work out the connections for the hallway

      if facing == FACING_X_MINUS then
        connected_x_minus = true
        if a_rooms[r - 1].m_content == CONTENT_HALLWAY then
          needs_door = false
        end
      elseif facing == FACING_X_PLUS then
        connected_x_plus  = true
        if a_rooms[r + 1].m_content == CONTENT_HALLWAY then
          needs_door = false
        end
      elseif facing == FACING_Y_MINUS then
        connected_y_minus = true
        if a_rooms[r - rooms_across].m_content == CONTENT_HALLWAY then
          needs_door = false
        end
      elseif facing == FACING_Y_PLUS then
        connected_y_plus  = true
        if a_rooms[r + rooms_across].m_content == CONTENT_HALLWAY then
          needs_door = false
        end
      else
        -- facing == FACING_NONE
        needs_door = false
      end

      if not connected_x_minus and
         x_base >= 1 and
         a_rooms[r - 1].m_facing_direction == FACING_X_PLUS and
         a_rooms[r - 1].m_content ~= CONTENT_SOLID then

        connected_x_minus = true
      end
      if not connected_x_plus and
         x_base < rooms_across - 1 and
         a_rooms[r + 1].m_facing_direction == FACING_X_MINUS and
         a_rooms[r + 1].m_content ~= CONTENT_SOLID then

        connected_x_plus = true
      end
      if not connected_y_minus and
         y_base >= 1 and
         a_rooms[r - rooms_across].m_facing_direction == FACING_Y_PLUS and
         a_rooms[r - rooms_across].m_content ~= CONTENT_SOLID then

        connected_y_minus = true
      end
      if not connected_y_plus and
         y_base < rooms_across - 1 and
         a_rooms[r + rooms_across].m_facing_direction == FACING_Y_MINUS and
         a_rooms[r + rooms_across].m_content ~= CONTENT_SOLID then

        connected_y_plus = true
      end

      mapAddRoomHallway(e, x, y,
                        size_group, facing,
                        '.',
                        connected_x_minus,
                        connected_x_plus,
                        connected_y_minus,
                        connected_y_plus)

      if needs_door then
        mapAddRoomDoor(e, x, y,
                       size_group,
                       facing,
                       'B',
                       true)
      end
    elseif content ~= CONTENT_SOLID then
      -- this is not a hallway room

      --  Rooms in a maze have no front unless
      --    they are dead ends.

      if a_rooms[r].m_attached_count > 0 then
        -- this it not a dead end

        mapAddRoom(e, x, y,
                   size_group,
                   FACING_NONE,
                   true,
                   content)

        if facing < FACING_DIRECTION_COUNT then
          mapAddRoomDoor(e, x, y,
                         size_group,
                         facing,
                         'B',
                         true)
        end

        -- consider adding an extra connection to side X+
        if crawl.random2(100) < extra_connection_percent and
           x_base < rooms_across - 1 and
           facing ~= FACING_X_PLUS then

          local other_room = y_base * rooms_across + (x_base + 1)
          if a_rooms[other_room].m_facing_direction ~= FACING_X_MINUS and
             a_rooms[other_room].m_attached_count >= 1 and
             a_rooms[other_room].m_content ~= CONTENT_SOLID then

            mapAddRoomDoor(e, x, y,
                           size_group,
                           FACING_X_PLUS,
                           'B',
                           true)
          end
        end

        -- consider adding an extra connection to side Y+
        if crawl.random2(100) < extra_connection_percent and
           y_base < rooms_across - 1 and
           facing ~= FACING_Y_PLUS then

          local other_room = (y_base + 1) * rooms_across + x_base
          if a_rooms[other_room].m_facing_direction ~= FACING_Y_MINUS and
             a_rooms[other_room].m_attached_count >= 1 and
             a_rooms[other_room].m_content ~= CONTENT_SOLID then

            mapAddRoomDoor(e, x, y,
                           size_group,
                           FACING_Y_PLUS,
                           'B',
                           true)
          end
        end
      else
        mapAddRoom(e, x, y,
                   size_group,
                   facing,
                   false,
                   content)
      end
    end
  end
end
}}



########
#
#  layoutCross
#
#  Purpose: To generate a map with the rooms connected to a
#           hallway in the shape of a cross.
#  Parameter(s):
#      <1> e: The global enviroment
#      <2> depth: The depth of the map within the branch
#      <3> a_group_frequency: The frequency of differant room
#                             groups
#      <4> a_content_frequency: The frequency of differant room
#                               content types
#      <5> content_solid_frequency: The frequency of a room
#                                   being filled with solid
#                                   wall
#      <6> a_entries: The content types for any branch or
#                     portal entries to add to the map
#  Preconditon(s):
#      <1> a_group_frequency != NULL
#      <2> a_group_frequency[ROOM_GROUP_TOTAL_FREQUENCY] > 0
#      <4> a_content_frequency != NULL
#  Returns: N/A
#  Side Effect: A map with hallways layed out in a cross is
#               generated and printed to standard output.  The
#               map is layed out as specified by
#               a_group_frequency and a_content_frequency in a
#               manner appropriate for depth depth.
#

{{
function layoutCross (e,
                      depth,
                      a_group_frequency,
                      a_content_frequency,
                      content_solid_frequency,
                      a_entries)

  assert(a_group_frequency ~= nil,
         "a_group_frequency cannot == nil")
  assert(a_group_frequency.total > 0,
         "total frequency must be > 0")
  assert(a_content_frequency ~= nil,
         "a_content_frequency cannot == nil")
  assert(a_entries ~= nil, "a_entries cannot == nil")

  --
  --  1. Chose rooms
  --
  --  First, we choose the width of the hallway.
  --
  --  There are 8 branches, 2 attached to each of 4
  --    corners, and each branch can have its own rooms.
  --
  --  The size of the corner rooms are chosen first.  No
  --    other room may be larger than this to avoid
  --    overlap.  Then, the rest of the rooms are chosen.
  --    To avoid silly-looking maps, the corner may not
  --    have a size group of ROOM_GROUP_CLOSET.
  --
  --  The required size for the hallway and corner rooms
  --    is that of the hallway, 2 rooms, and 4 walls.
  --

  local size_hallway = getRandomHallwaySize(depth)

  local group_corner = getRandomGroupCorner(depth, a_group_frequency)
  if group_corner == ROOM_GROUP_CLOSET then
    group_corner = ROOM_GROUP_FIRST_NON_CLOSET
  end
  local size_corner = A_ROOM_SIZE[group_corner]

  local size_map_maximum = getMaximumMapSize(depth)
  local size_branch_maximum = size_map_maximum -
                               (size_hallway + size_corner * 2 + 4)
  -- split the size between 2 sides
  size_branch_maximum = math.floor(size_branch_maximum / 2)

  local aa_count_group_for_branch = {}
  local a_count_total_for_branch = {}
  local a_size_total_for_branch = {}
  for b = 0, CROSS_BRANCH_COUNT - 1 do
    aa_count_group_for_branch[b] = {}
    a_size_total_for_branch[b] =
                    calculateRoomsForLine(size_branch_maximum,
                                          size_branch_maximum,
                                          a_group_frequency,
                                          group_corner,
                                          aa_count_group_for_branch[b],
                                          false)

    a_count_total_for_branch[b] =
                    getRoomCountTotal(aa_count_group_for_branch[b])

    -- if we could not pick a room, add the largest room we can
    if a_count_total_for_branch[b] == 0 then
      for g = ROOM_GROUP_COUNT - 1, ROOM_GROUP_CLOSET, -1 do
        local size = A_ROOM_SIZE[g]
        if size + 1 <= size_branch_maximum then
          --  I wish for +=
          aa_count_group_for_branch[b][g] = aa_count_group_for_branch[b][g] + 1
          a_count_total_for_branch[b] = a_count_total_for_branch[b] + 1
          a_size_total_for_branch[b] = a_size_total_for_branch[b] + size + 1
          break
        end
      end
    end
  end

  --
  --  2. Assign the rooms to positions
  --

  local a_start_index = {}
  local room_count_total = 4
  for b = 0, CROSS_BRANCH_COUNT - 1 do
    a_start_index[b] = room_count_total
    room_count_total = room_count_total + a_count_total_for_branch[b]
  end

  local a_rooms = {}

  -- inside corners
  local corner_index_xm_ym = 0
  local corner_index_xm_yp = 1
  local corner_index_xp_ym = 2
  local corner_index_xp_yp = 3
  for c = 0, 3 do
    a_rooms[c] = createDefaultRoom(group_corner)
  end

  -- branches
  for b = 0, CROSS_BRANCH_COUNT - 1 do
    local corner_index

    -- figure out which corners they connect to
    if b == 0 or b == 1 then
      corner_index = corner_index_xm_ym
    elseif b == 2 or b == 3 then
      corner_index = corner_index_xm_yp
    elseif b == 4 or b == 5 then
      corner_index = corner_index_xp_ym
    elseif b == 6 or b == 7 then
      corner_index = corner_index_xp_yp
    end

    calculateRoomOrder(aa_count_group_for_branch[b],
                       false,
                       a_count_total_for_branch[b],
                       a_rooms,
                       room_count_total,
                       a_start_index[b],
                       corner_index,
                       NO_ROOM)
  end

  --
  --  3. Assign room contents
  --

  calculateContentStairs(a_rooms, room_count_total,
                         depth)
  calculateContentBranchPortal(a_rooms, room_count_total,
                               a_entries)
  calculateContentSerialVault(a_rooms, room_count_total)
  calculateContentSolid(a_rooms, room_count_total,
                        a_content_frequency,
                        content_solid_frequency)
  calculateContentProbability(a_rooms, room_count_total,
                              a_content_frequency)
  connectDisconnectedRooms(a_rooms, room_count_total)

  --
  --  4. Print out layout statistics
  --

  if PRINT_LAYOUT_STATISTICS then
    crawl.mpr("Layout Statistics (Cross)")
    crawl.mpr("  Depth: " .. depth)
    crawl.mpr("  Largest group: " .. getLargestGroup(a_group_frequency))
    local line = "  Frequencies:"
    for g = 0, ROOM_GROUP_COUNT - 1 do
      line = line .. "    " .. g .. ": " .. a_group_frequency[g]
    end
    line = line .. "    = " .. a_group_frequency.total
    crawl.mpr(line)
    crawl.mpr("  Total rooms: " .. room_count_total)
    crawl.mpr("  Maximum size per branch: " .. size_branch_maximum)
    crawl.mpr("  Corner rooms: " .. group_corner ..
              " (" .. size_corner .. "x" .. size_corner ..")")
    for b = 0, CROSS_BRANCH_COUNT - 1 do
      line = "  Branch rooms " .. b .. ":"
      line = line .. " total length: " .. a_size_total_for_branch[b]
      for r = 0, a_count_total_for_branch[b] - 1 do
        local index = a_start_index[b] + r
        if a_rooms[index].m_is_dummy_wall then
          line = line .. "    X"
        else
          line = line .. "    " .. a_rooms[index].m_group
        end
      end
      crawl.mpr(line)
    end
    crawl.mpr("  Hallway size: " .. size_hallway .. " (min " ..
              getMinimumHallwaySize(depth) .. ")")
  end

  --
  --  5. Generate map
  --

  -- add cross hallway
  --
  --    1 | 5
  --  0 * | * 4
  --  ----+----
  --  2 * | * 6
  --    3 | 7
  --

  --  This seems to be centered in an area the chosen map size,
  --    not aligned to the top-left corner.  Opps.
  local hallway_arm_from_edge =
                math.floor((size_map_maximum - size_hallway) / 2)
  local hallway_far_side = hallway_arm_from_edge + size_hallway
  local arm_length_x_minus = size_corner + 1 +
                             math.max(a_size_total_for_branch[0],
                                      a_size_total_for_branch[2])
  local arm_length_x_plus  = size_corner + 1 +
                             math.max(a_size_total_for_branch[4],
                                      a_size_total_for_branch[6])
  local arm_length_y_minus = size_corner + 1 +
                             math.max(a_size_total_for_branch[1],
                                      a_size_total_for_branch[5])
  local arm_length_y_plus  = size_corner + 1 +
                             math.max(a_size_total_for_branch[3],
                                      a_size_total_for_branch[7])

  e.fill_area{x1=(hallway_arm_from_edge - arm_length_x_minus),
              y1=(hallway_arm_from_edge),
              x2=(hallway_far_side + arm_length_x_plus - 1),
              y2=(hallway_far_side - 1),
              fill='.'}
  e.fill_area{x1=(hallway_arm_from_edge),
              y1=(hallway_arm_from_edge - arm_length_y_minus),
              x2=(hallway_far_side - 1),
              y2=(hallway_far_side + arm_length_y_plus - 1),
              fill='.'}

  -- add corners
  local corner_position_minus = hallway_arm_from_edge - (size_corner + 1)
  local corner_position_plus  = hallway_arm_from_edge + size_hallway + 1
  local is_room_attached

  is_room_attached = false
  if a_rooms[corner_index_xm_ym].m_attached_count > 0 then
    is_room_attached = true
  end
  mapAddRoom(e,
             corner_position_minus,
             corner_position_minus,
             a_rooms[corner_index_xm_ym].m_group,
             FACING_CORNER_XP_YP,
             is_room_attached,
             a_rooms[corner_index_xm_ym].m_content)

  is_room_attached = false
  if a_rooms[corner_index_xm_yp].m_attached_count > 0 then
    is_room_attached = true
  end
  mapAddRoom(e,
             corner_position_minus,
             corner_position_plus,
             a_rooms[corner_index_xm_yp].m_group,
             FACING_CORNER_XP_YM,
             is_room_attached,
             a_rooms[corner_index_xm_yp].m_content)

  is_room_attached = false
  if a_rooms[corner_index_xp_ym].m_attached_count > 0 then
    is_room_attached = true
  end
  mapAddRoom(e,
             corner_position_plus,
             corner_position_minus,
             a_rooms[corner_index_xp_ym].m_group,
             FACING_CORNER_XM_YP,
             is_room_attached,
             a_rooms[corner_index_xp_ym].m_content)

  is_room_attached = false
  if a_rooms[corner_index_xp_yp].m_attached_count > 0 then
    is_room_attached = true
  end
  mapAddRoom(e,
             corner_position_plus,
             corner_position_plus,
             a_rooms[corner_index_xp_yp].m_group,
             FACING_CORNER_XM_YM,
             is_room_attached,
             a_rooms[corner_index_xp_yp].m_content)

  -- add branch rooms
  local branch_start_plus = corner_position_plus + size_corner + 1
  for b = 0, CROSS_BRANCH_COUNT - 1 do
    local along_pos = 0

    for r = 0, a_count_total_for_branch[b] - 1 do
      local index = a_start_index[b] + r

      local group = a_rooms[index].m_group
      local size = A_ROOM_SIZE[group]
      local connection = a_rooms[index].m_connection
      local facing = getCrossFacingDirection(b, connection)
      local content = a_rooms[index].m_content
      local is_room_attached = false
      if a_rooms[index].m_attached_count > 0 then
        is_room_attached = true
      end

      --
      --    1 | 5
      --  0 * | * 4
      --  ----+----
      --  2 * | * 6
      --    3 | 7
      --

      local x
      local y
      local along_pos_far = along_pos + size + 1
      if b == 0 then
        x = corner_position_minus - along_pos_far
        y = hallway_arm_from_edge - (size + 1)
      elseif b == 1 then
        x = hallway_arm_from_edge - (size + 1)
        y = corner_position_minus - along_pos_far
      elseif b == 2 then
        x = corner_position_minus - along_pos_far
        y = corner_position_plus
      elseif b == 3 then
        x = hallway_arm_from_edge - (size + 1)
        y = branch_start_plus + along_pos
      elseif b == 4 then
        x = branch_start_plus + along_pos
        y = hallway_arm_from_edge - (size + 1)
      elseif b == 5 then
        x = corner_position_plus
        y = corner_position_minus - along_pos_far
      elseif b == 6 then
        x = branch_start_plus + along_pos
        y = corner_position_plus
      else
        -- b == 7
        x = corner_position_plus
        y = branch_start_plus + along_pos
      end

      mapAddRoom(e, x, y, group, facing, is_room_attached, content)

      along_pos = along_pos + size + 1
    end
  end
end
}}



########
#
#  layoutWalkways
#
#  Fundementally, this is a more complex form of the layoutCross
#    function.  Each place where a hallway branches of the
#    central hallway is basically a mini-cross.  However, there
#    are enough differances to make combining the two
#    impractical.  I strongly recommend that you do not try to
#    understand how this works before you figure out the cross
#    hallway.
#
#  Purpose: To generate a map with the rooms connected to a
#           branches off a central hallway.  The central
#           hallway goes in the x direction and the branch
#           hallways go in the y direction.
#  Parameter(s):
#      <1> e: The global enviroment
#      <2> depth: The depth of the map within the branch
#      <3> a_group_frequency: The frequency of differant room
#                             groups
#      <4> a_content_frequency: The frequency of differant room
#                               content types
#      <6> content_solid_frequency: The frequency of a room
#                                   being filled with solid
#                                   wall
#      <7> a_entries: The content types for any branch or portal
#                     entries to add to the map
#  Preconditon(s):
#      <1> a_group_frequency != NULL
#      <2> a_group_frequency[ROOM_GROUP_TOTAL_FREQUENCY] > 0
#      <4> a_content_frequency != NULL
#      <5> a_entries != NULL
#  Returns: N/A
#  Side Effect: A map layed out with a central hallway with
#               hallways branching off it and rooms attached to
#               the branch hallways is generated and printed to
#               standard output.  The map is layed out as
#               specified by a_group_frequency and
#               a_content_frequency in a manner appropriate for
#               depth depth.
#

{{
function layoutWalkways (e,
                         depth,
                         a_group_frequency,
                         a_content_frequency,
                         content_solid_frequency,
                         a_entries)

  assert(a_group_frequency ~= nil,
         "a_group_frequency cannot == nil")
  assert(a_group_frequency.total > 0,
         "total frequency must be > 0")
  assert(a_content_frequency ~= nil,
         "a_content_frequency cannot == nil")
  assert(a_entries ~= nil, "a_entries cannot == nil")

  --
  --  1. Chose hallway sizes
  --
  --  We choose two hallway sizes.  The larger becomes the
  --    central hallway and the smaller becomes the branch
  --    hallways.
  --

  local size_hallway1
  local size_hallway2
  local size_hallway_center
  local size_hallway_branch

  size_hallway1 = getRandomHallwaySize(depth)
  size_hallway2 = getRandomHallwaySize(depth)

  if size_hallway1 >= size_hallway2 then
    size_hallway_center = size_hallway1
    size_hallway_branch = size_hallway2
  else
    size_hallway_center = size_hallway2
    size_hallway_branch = size_hallway1
  end

  --
  --  2. Chose corner room sizes
  --
  --  We start by choosing pairs room groups for corner
  --    rooms until no more fit in the map.  If we do not
  --    get at least 4 rooms across, we add the largest
  --    rooms that fit.  This may result in rooms smaller
  --    than the official limit.
  --
  --  A branch with no rooms needs enough space for the
  --    branch hallway 3 walls.  The map as a whole also
  --    needs one more wall for the end.
  --

  -- we will get to these below
  local size_map_x
  local size_map_y

  -- determine the maximum map size
  local size_map_maximum = getMaximumMapSize(depth)

  -- choose random sizes for corner rooms
  local size_branch_minus_rooms = size_hallway_branch + 3
  local a_count_group_corner = {}
  for g = 0, ROOM_GROUP_COUNT - 1 do
    a_count_group_corner[g] = 0
  end
  local branch_count_per_side = 0
  local total_size_x_used = 0

  -- loop drops out below
  while true do

    local group1 = getRandomGroupCorner(depth, a_group_frequency)
    if group1 == ROOM_GROUP_CLOSET then
      group1 = ROOM_GROUP_FIRST_NON_CLOSET
    end
    local size1 = A_ROOM_SIZE[group1]

    local group2 = getRandomGroupCorner(depth, a_group_frequency)
    if group2 == ROOM_GROUP_CLOSET then
      group2 = ROOM_GROUP_FIRST_NON_CLOSET
    end
    local size2 = A_ROOM_SIZE[group2]

    local total_size = size_branch_minus_rooms + size1 + size2
    if total_size_x_used + total_size + 1 > size_map_maximum then
      -- drop out when no more rooms fit
      break
    else
      a_count_group_corner[group1] = a_count_group_corner[group1] + 1
      a_count_group_corner[group2] = a_count_group_corner[group2] + 1
      branch_count_per_side = branch_count_per_side + 1
      total_size_x_used = total_size_x_used + total_size
    end
  end

  -- if we did not get enough rooms, add the largest pair of rooms we can
  if branch_count_per_side < 2 then
    for g = ROOM_GROUP_COUNT - 1, ROOM_GROUP_CLOSET, -1 do
      local size = A_ROOM_SIZE[g]
      local total_size = size_branch_minus_rooms + size * 2

      if total_size_x_used + total_size + 1 <= size_map_maximum then
        a_count_group_corner[g] = a_count_group_corner[g] + 2
        branch_count_per_side = branch_count_per_side + 1
        total_size_x_used = total_size_x_used + total_size
      end
    end
  end

  -- calculate the maximum size
  size_map_x = total_size_x_used + 1

  --
  --  3. Chose the order for corner rooms
  --
  --  Each corner room size we chose will be used twice,
  --    once above the center hallway and once below it.
  --    The onces in the bottom will be in the same order
  --    as the top, except that the corner rooms between
  --    adjacent branches may be switched.
  --
  --    |    |    |
  --   A|B  C|D  E|F   Bottom rooms B and C switched
  --  --+----+----+--  Bottom rooms D and E did not switch
  --   A|C  B|D  E|F   Bottom room A had no switch partner
  --    |    |    |
  --
  --  To pick the order for the rooms, we start by putting
  --    all the rooms for the top into an array in random
  --    order.  Then, we space out the array so that each
  --    room is in it twice, once for the top and once for
  --    the bottom.  Finally, we go through the bottom
  --    values and switch them 50% of the time.
  --
  --  Order for corner rooms:
  --    |    |    |
  --   0|2  4|6  8|10
  --  --+----+----+--
  --   1|3  5|7  9|11
  --    |    |    |
  --

  -- add all the corner rooms for the top to an array in random order
  local total_corner_rooms = branch_count_per_side *
                             WALKWAYS_CORNERS_PER_BRANCH
  local a_group_corner = {}
  local next_corner_room_index = 0
  for g = 0, ROOM_GROUP_COUNT - 1 do
    for i = 0, a_count_group_corner[g] - 1 do
      local add_index = crawl.random2(next_corner_room_index + 1)
      a_group_corner[next_corner_room_index] = a_group_corner[add_index]
      a_group_corner[add_index] = g
      next_corner_room_index = next_corner_room_index + 1
    end
  end

  -- space out the array
  for c = total_corner_rooms - 1, 0, -1 do
    a_group_corner[c] = a_group_corner[math.floor(c / 2)]
  end

  -- swap some elements on the bottom

  --  This is the differance in the array indexes between
  --    adjacent bottom corner elements
  local bottom_corner_spacing = WALKWAYS_CORNERS_PER_BRANCH / 2

  for c = bottom_corner_spacing,
          total_corner_rooms - WALKWAYS_CORNERS_PER_BRANCH - 1,
          WALKWAYS_CORNERS_PER_BRANCH do

    if crawl.random2(2) < 1 then
      local other_index = c + bottom_corner_spacing
      local temp = a_group_corner[c]
      a_group_corner[c] = a_group_corner[other_index]
      a_group_corner[other_index] = temp
    end
  end

  --
  --  4. Chose the non-corner room sizes
  --
  --  We calculate how many of each type of room should
  --    be in each branch.  We have to leave room for the
  --    central hallway, the corner rooms, and four walls.
  --
  --  Remember that the main hallway goes in the x
  --    direction and the branches go in the y direction.
  --
  --  Also remember that some corners may be smaller than
  --    the legal minimum size group.
  --

  local size_branch_y_maximum = size_map_maximum - (size_hallway_center + 2)
  -- split the size between 2 sides
  size_branch_y_maximum = math.floor(size_branch_y_maximum / 2)

  local size_branch_y_minus_largest = 0
  local size_branch_y_plus_largest  = 0

  -- allocate the arrays for the rooms sizes behind each corner
  local a_size_branch_y_real      = {}
  local aa_count_group_for_corner = {}
  local a_count_total_for_corner  = {}
  local a_size_total_for_corner   = {}

  for b = 0, branch_count_per_side - 1 do
    for i = 0, WALKWAYS_CORNERS_PER_BRANCH - 1 do
      local corner_index = b * WALKWAYS_CORNERS_PER_BRANCH + i
      local group_corner = a_group_corner[corner_index]
      local size_corner = A_ROOM_SIZE[group_corner]

      local group_largest = getLargestGroup(a_group_frequency)
      local available_space = size_branch_y_maximum - (size_corner + 1)

      aa_count_group_for_corner[corner_index] = {}

      if group_corner >= group_largest then
        -- choose the rooms using frequencies

        a_size_total_for_corner[corner_index] =
                calculateRoomsForLine(
                        available_space,
                        available_space,
                        a_group_frequency,
                        group_corner,
                        aa_count_group_for_corner[corner_index],
                        false)
      else
        -- just add rooms the size of the corner room

        aa_count_group_for_corner[corner_index] = {}
        for g = 0, ROOM_GROUP_COUNT - 1 do
          aa_count_group_for_corner[corner_index][g] = 0
        end

        local room_count = math.floor(available_space / (size_corner + 1))
        aa_count_group_for_corner[corner_index][group_corner] = room_count
        a_size_total_for_corner[corner_index] = room_count * (size_corner + 1)
      end

      a_count_total_for_corner[corner_index] =
              getRoomCountTotal(aa_count_group_for_corner[corner_index])

      a_size_branch_y_real[corner_index] =
              (size_corner + 1) + a_size_total_for_corner[corner_index]

      --
      --    |
      --   0|2
      --  --+--
      --   1|3
      --    |
      --

      if i == 0 or i == 2 then
        if a_size_branch_y_real[corner_index] >
           size_branch_y_minus_largest then
          size_branch_y_minus_largest = a_size_branch_y_real[corner_index]
        end
      else
        -- i == 1 or i == 3
        if a_size_branch_y_real[corner_index] >
           size_branch_y_plus_largest then
          size_branch_y_plus_largest = a_size_branch_y_real[corner_index]
        end
      end
    end
  end

  size_map_y = size_hallway_center + 2 +
               size_branch_y_minus_largest +
               size_branch_y_plus_largest

  --
  --  5. Assign the rooms to positions
  --
  --  There are branches on each side of the central
  --    hallway, and rooms on each side of each branch.
  --

  local room_count_total = 0
  local a_start_index = {}
  for c = 0, total_corner_rooms - 1 do
    a_start_index[c] = room_count_total

    -- +1 for the corner
    room_count_total = room_count_total + a_count_total_for_corner[c] + 1
  end
  local a_rooms = {}

  -- choose an order for the rooms on each branch
  for b = 0, branch_count_per_side - 1 do
    -- choose an order for the rooms attached to each corner
    for i = 0, WALKWAYS_CORNERS_PER_BRANCH - 1 do
      local corner_index = b * WALKWAYS_CORNERS_PER_BRANCH + i
      local start_index = a_start_index[corner_index]

      local room_count_for_corner = a_count_total_for_corner[corner_index]

      a_rooms[start_index] = createDefaultRoom(a_group_corner[corner_index])

      calculateRoomOrder(aa_count_group_for_corner[corner_index],
                         false,
                         room_count_for_corner,
                         a_rooms,
                         room_count_total,
                         start_index + 1,
                         start_index,
                         NO_ROOM)
    end
  end

  --
  --  6. Assign room contents
  --

  calculateContentStairs(a_rooms, room_count_total,
                         depth)
  calculateContentBranchPortal(a_rooms, room_count_total,
                               a_entries)
  calculateContentSerialVault(a_rooms, room_count_total)
  calculateContentSolid(a_rooms, room_count_total,
                        a_content_frequency,
                        content_solid_frequency)
  calculateContentProbability(a_rooms, room_count_total,
                              a_content_frequency)
  connectDisconnectedRooms(a_rooms, room_count_total)

  --
  --  7. Print out layout statistics
  --

  if PRINT_LAYOUT_STATISTICS then
    crawl.mpr("Layout Statistics (Walkways)")
    crawl.mpr("  Depth: " .. depth)
    crawl.mpr("  Largest group: " .. getLargestGroup(a_group_frequency))
    local line = "  Frequencies:"
    for g = 0, ROOM_GROUP_COUNT - 1 do
      line = line .. "    " .. g .. ": " .. a_group_frequency[g]
    end
    line = line .. "    = " .. a_group_frequency.total
    crawl.mpr(line)
    crawl.mpr("  Total rooms: " .. room_count_total)
    crawl.mpr("  Branches across: " .. branch_count_per_side)
    crawl.mpr("  Branch length maximum: " .. size_branch_y_maximum)
    for b = 0, branch_count_per_side - 1 do
      crawl.mpr("  Branch " .. b .. ":")
      for i = 0, WALKWAYS_CORNERS_PER_BRANCH - 1 do
        local corner_index = b * WALKWAYS_CORNERS_PER_BRANCH + i
        local start_index = a_start_index[corner_index]

        crawl.mpr("    Corner " .. i .. ":")
        crawl.mpr("      Total length: " .. a_size_branch_y_real[corner_index])
        crawl.mpr("      Start index: " .. start_index)
        crawl.mpr("      Corner room: " .. a_rooms[start_index].m_group)

        line = "      Rooms excluding corner:"
        local room_count = a_count_total_for_corner[corner_index]
        for r = 0, room_count - 1 do
          local index = start_index + 1 + r
          if a_rooms[index].m_is_dummy_wall then
            line = line .. "    X"
          else
            line = line .. "    " .. a_rooms[index].m_group
          end
        end
        crawl.mpr(line)
      end
    end
    crawl.mpr("  Central hallway size: " .. size_hallway_center)
    crawl.mpr("  Branch hallway size:  " .. size_hallway_branch)
    crawl.mpr("  Mimimum hallway size: " .. getMinimumHallwaySize(depth))
    crawl.mpr("  Map size: " .. size_map_x .. " x " .. size_map_y)
  end

  --
  --  8. Generate map
  --
  --  We will keep a special running total going for the
  --    x-coordinate of the next branch hallway.
  --

  -- add the central hallway
  local center_hallway_y_minus = size_branch_y_minus_largest + 1
  local center_hallway_y_plus  = center_hallway_y_minus + size_hallway_center

  e.fill_area{x1=1,                y1=center_hallway_y_minus,
              x2=(size_map_x - 2), y2=(center_hallway_y_plus - 1),
              fill='.'}

  -- calculate the position for the first branch hallway
  local corner_group_for_hallway_x = a_rooms[a_start_index[0]].m_group
  local branch_base_x = A_ROOM_SIZE[corner_group_for_hallway_x] + 2

  -- add the branches
  for b = 0, branch_count_per_side - 1 do

    if b > 0 then
      -- update the position for the next branch hallway

      local corner_index_next = b * WALKWAYS_CORNERS_PER_BRANCH
      local corner_index_previous = corner_index_next - 2

      -- add on space for the hallway and walls
      branch_base_x = branch_base_x + size_hallway_branch + 3

      -- add on space for one room
      local room_index1 = a_start_index[corner_index_previous]
      local room_group1 = a_rooms[room_index1].m_group
      branch_base_x = branch_base_x + A_ROOM_SIZE[room_group1]

      -- add on space for the other room
      local room_index2 = a_start_index[corner_index_next]
      local room_group2 = a_rooms[room_index2].m_group
      branch_base_x = branch_base_x + A_ROOM_SIZE[room_group2]
    end

    local branch_hallway_x_minus = branch_base_x
    local branch_hallway_x_plus = branch_hallway_x_minus +
                                  size_hallway_branch

    -- add the branch hallway
    e.fill_area{x1=branch_hallway_x_minus,
                y1=1,
                x2=(branch_hallway_x_minus + size_hallway_branch - 1),
                y2=(size_map_y - 2),
                fill='.'}


    -- add four lines of rooms
    for i = 0, WALKWAYS_CORNERS_PER_BRANCH - 1 do
      local corner_index = b * WALKWAYS_CORNERS_PER_BRANCH + i
      local start_index = a_start_index[corner_index]

      -- add the corner room

      local group_corner = a_rooms[start_index].m_group
      local size_corner = A_ROOM_SIZE[group_corner]
      local corner_is_room_attached = false
      if a_rooms[start_index].m_attached_count > 0 then
        corner_is_room_attached = true
      end
      local corner_content = a_rooms[start_index].m_content

      --
      --    |
      --   0|2
      --  --+--
      --   1|3
      --    |
      --

      local corner_x
      local corner_y
      local corner_facing
      if i == 0 then
        corner_x = branch_hallway_x_minus - (size_corner + 1)
        corner_y = center_hallway_y_minus - (size_corner + 1)
        corner_facing = FACING_CORNER_XP_YP
      elseif i == 1 then
        corner_x = branch_hallway_x_minus - (size_corner + 1)
        corner_y = center_hallway_y_plus + 1
        corner_facing = FACING_CORNER_XP_YM
      elseif i == 2 then
        corner_x = branch_hallway_x_plus + 1
        corner_y = center_hallway_y_minus - (size_corner + 1)
        corner_facing = FACING_CORNER_XM_YP
      else
        corner_x = branch_hallway_x_plus + 1
        corner_y = center_hallway_y_plus + 1
        corner_facing = FACING_CORNER_XM_YM
      end

      mapAddRoom(e,
                 corner_x,
                 corner_y,
                 group_corner,
                 corner_facing,
                 corner_is_room_attached,
                 corner_content)

      -- add the other rooms

      local along_pos = size_corner + 1
      local room_count = a_count_total_for_corner[corner_index]
      for r = 0, room_count - 1 do
        local index = start_index + 1 + r

        local group = a_rooms[index].m_group
        local size = A_ROOM_SIZE[group]
        local connection = a_rooms[index].m_connection
        local facing = getWalkwaysFacingDirection(i, connection)
        local is_room_attached = false
        if a_rooms[index].m_attached_count > 0 then
          is_room_attached = true
        end
        local content = a_rooms[index].m_content

        --
        --    |
        --   0|2
        --  --+--
        --   1|3
        --    |
        --

        local x
        local y
        if i == 0 then
          x = branch_hallway_x_minus - (size + 1)
          y = center_hallway_y_minus - along_pos - (size + 1)
        elseif i == 1 then
          x = branch_hallway_x_minus - (size + 1)
          y = center_hallway_y_plus + along_pos + 1
        elseif i == 2 then
          x = branch_hallway_x_plus + 1
          y = center_hallway_y_minus - along_pos - (size + 1)
        else
          -- i == 3
          x = branch_hallway_x_plus + 1
          y = center_hallway_y_plus + along_pos + 1
        end

        mapAddRoom(e, x, y, group, facing, is_room_attached, content)

        along_pos = along_pos + size + 1
      end
    end
  end
end
}}



########
#
#  layoutSquareRing
#
#  Purpose: To generate a map with the rooms connected to a
#       hallway in the shape of a square ring.
#  Parameter(s):
#      <1> e: The global enviroment
#      <2> depth: The depth of the map within the branch
#      <3> a_group_frequency: The frequency of differant room
#                             groups
#      <4> a_content_frequency: The frequency of differant room
#                               content types
#      <5> content_solid_frequency: The frequency of a room
#                                   being filled with solid
#                                   wall
#      <6> a_entries: The content types for any branch or portal
#                     entries to add to the map
#  Preconditon(s):
#      <1> a_group_frequency != NULL
#      <2> a_group_frequency[ROOM_GROUP_TOTAL_FREQUENCY] > 0
#      <3> a_content_frequency != NULL
#      <4> a_entries != NULL
#  Returns: N/A
#  Side Effect: A map with hallways layout out around a square
#               ring is generated and printed to standard
#               output.  The map is layed out as specified by
#               a_group_frequency and a_content_frequency in a
#               manner appropriate for depth depth.
#

{{
function layoutSquareRing (e,
                           depth,
                           a_group_frequency,
                           a_content_frequency,
                           content_solid_frequency,
                           a_entries)

  assert(a_group_frequency ~= nil,
         "a_group_frequency cannot == nil")
  assert(a_group_frequency.total > 0,
         "total frequency must be > 0")
  assert(a_content_frequency ~= nil,
         "a_content_frequency cannot == nil")
  assert(a_entries ~= nil, "a_entries cannot == nil")

  --
  --  1. Chose rooms for outside of hallway
  --
  --  All four sides of the ring have the same number of
  --    rooms in each group.  However, these order and
  --    content of these rooms is chosen randomly for each
  --    side.
  --
  --  Space must be left for a room of each side of the
  --    hallway and three walls between them.  That is one
  --    wall for each outside and one for the middle.  The
  --    other middle wall will be added with a room.  An
  --    additional space is left so that the total size
  --    can be expanded by 1 if needed to make the
  --    hallways on both sides the same size.
  --
  --  We guarentee at least 2 rooms on each side.  If they do not
  --    fit, we add a closet.
  --

  local group_largest_outside = getRandomGroupCorner(depth, a_group_frequency)
  if group_largest_outside == ROOM_GROUP_CLOSET then
    group_largest_outside = ROOM_GROUP_FIRST_NON_CLOSET
  end
  local size_largest_outside = A_ROOM_SIZE[group_largest_outside]

  local size_maximum_outside = getMaximumMapSize(depth) -
          (size_largest_outside * 2 + 3)

  local a_count_group_per_side_outside = {}
  local size_total_per_side_outside =
          calculateRoomsForLine(size_maximum_outside,
                                size_maximum_outside,
                                a_group_frequency,
                                group_largest_outside,
                                a_count_group_per_side_outside,
                                true) - 1
  -- one wall is off the edge, so -1

  local count_total_per_side_outside =
          getRoomCountTotal(a_count_group_per_side_outside)

  -- if we did not get enough rooms, add some closets
  while count_total_per_side_outside < 2 do
    a_count_group_per_side_outside[ROOM_GROUP_CLOSET] =
            a_count_group_per_side_outside[ROOM_GROUP_CLOSET] + 1
    size_total_per_side_outside = size_total_per_side_outside + 2
    count_total_per_side_outside = count_total_per_side_outside + 1
  end

  --
  --  2. Chose rooms for inside of hallway
  --
  --  The corners must have rooms of the largest group.
  --    Otherwise, there is the danger of large
  --    neighbouring rooms attempting to overlap.  To
  --    avoid really-silly-looking maps, the corner rooms
  --    cannot have be in size group ROOM_GROUP_CLOSET.
  --
  --  If the room group we wanted for the corners does not
  --    fit, we put in the largest one that does.  This
  --    may be smaller than the smallest room group
  --    officially in use.
  --
  --  If just the corners are generated, space is needed
  --    for two hallways, two rooms, and three walls.
  --

  local size_hallway_minimum = getMinimumHallwaySize(depth)
  local size_maximum_inside = size_total_per_side_outside -
                              size_hallway_minimum * 2

  local group_corner = getRandomGroupCorner(depth, a_group_frequency)
  if group_corner == ROOM_GROUP_CLOSET then
    group_corner = ROOM_GROUP_FIRST_NON_CLOSET
  end
  local size_corner = A_ROOM_SIZE[group_corner]

  -- does not include corners
  local a_count_group_per_side_inside = {}
  -- includes corners
  local size_total_per_side_inside = size_corner * 2 + 3
  local count_total_per_side_inside

  if size_total_per_side_inside > size_maximum_inside then
    -- try smaller rooms for the center until something fits

    for g = ROOM_GROUP_COUNT - 1, ROOM_GROUP_CLOSET, -1 do
      group_corner = g
      size_corner = A_ROOM_SIZE[group_corner]
      size_total_per_side_inside = size_corner * 2 + 3

      if size_total_per_side_inside <= size_maximum_inside then
        -- if this is small enough, stop
        break
      end
    end

    for i = 0, ROOM_GROUP_COUNT - 1 do
      a_count_group_per_side_inside[i] = 0
    end
    count_total_per_side_inside = 0

  else
    -- stick in as many more rooms as possible

    local size_effective_maximum = size_maximum_inside -
                                   size_total_per_side_inside

    -- total_inside_size includes corners
    size_total_per_side_inside =
            size_total_per_side_inside +
            calculateRoomsForLine(size_effective_maximum,
                                  size_effective_maximum,
                                  a_group_frequency,
                                  group_corner,
                                  a_count_group_per_side_inside,
                                  false)

    count_total_per_side_inside =
            getRoomCountTotal(a_count_group_per_side_inside)
  end

  --
  --  3. Calculate hallway information
  --
  --  We first check to see if we need an extra wall
  --    between the outside rooms.  We add this wall if we
  --    need it to make the hallways on both sides the
  --    same size.
  --

  local is_extra_wall = false
  if (size_total_per_side_outside - size_total_per_side_inside) % 2 ~= 0 then
    -- an extra wall has size 1 including the wall
    is_extra_wall = true
    count_total_per_side_outside = count_total_per_side_outside + 1
    size_total_per_side_outside = size_total_per_side_outside + 1
  end

  local size_hallway = (size_total_per_side_outside -
                        size_total_per_side_inside) / 2

  local hallway_minus_outside = size_largest_outside + 2
  local hallway_minus_inside  = hallway_minus_outside + size_hallway
  local hallway_plus_inside   = hallway_minus_inside +
                                size_total_per_side_inside
  local hallway_plus_outside  = hallway_plus_inside + size_hallway

  --
  --  4. Assign the rooms to positions
  --
  --  There are a total of 8 lines of rooms to assign.
  --    -> 4 on the outside
  --    -> 4 on the inside between the corners
  --

  local room_count_total = (count_total_per_side_outside +
                            count_total_per_side_inside) *
                                   FACING_DIRECTION_COUNT + 4
  local a_rooms = {}

  -- inside corners
  local corner_index_xm_ym = room_count_total - 4
  local corner_index_xm_yp = room_count_total - 3
  local corner_index_xp_ym = room_count_total - 2
  local corner_index_xp_yp = room_count_total - 1
  for c = room_count_total - 4, room_count_total - 1 do
    a_rooms[c] = createDefaultRoom(group_corner)
  end

  -- edges
  for e = 0, FACING_DIRECTION_COUNT - 1 do
    local start_index_outside = count_total_per_side_outside * e

    -- outside edges
    calculateRoomOrder(a_count_group_per_side_outside,
                       is_extra_wall,
                       count_total_per_side_outside,
                       a_rooms,
                       room_count_total,
                       start_index_outside,
                       NO_ROOM,
                       NO_ROOM)

    -- inside edges
    if count_total_per_side_inside > 0 then

      local start_index_inside = count_total_per_side_outside *
                                 FACING_DIRECTION_COUNT +
                                 count_total_per_side_inside * e

      --
      --     2----->
      --  0 +-------+ 1
      --  | |*6--->*| |
      --  | |4     5| |
      --  | |v     v| |
      --  | |*7--->*| |
      --  v +-------+ v
      --     3----->
      --

      -- figure out which corners they connect to
      local corner_before
      local corner_after
      if e == FACING_X_MINUS then
        corner_before = corner_index_xm_ym
        corner_after  = corner_index_xm_yp
      elseif e == FACING_X_PLUS then
        corner_before = corner_index_xp_ym
        corner_after  = corner_index_xp_yp
      elseif e == FACING_Y_MINUS then
        corner_before = corner_index_xm_ym
        corner_after  = corner_index_xp_ym
      else
        -- e == FACING_Y_PLUS
        corner_before = corner_index_xm_yp
        corner_after  = corner_index_xp_yp
      end

      calculateRoomOrder(a_count_group_per_side_inside,
                         false,
                         count_total_per_side_inside,
                         a_rooms,
                         room_count_total,
                         start_index_inside,
                         corner_before,
                         corner_after)
    end
  end

  --
  --  5. Assign room contents
  --

  calculateContentStairs(a_rooms, room_count_total,
                         depth)
  calculateContentBranchPortal(a_rooms, room_count_total,
                               a_entries)
  calculateContentSerialVault(a_rooms, room_count_total)
  calculateContentSolid(a_rooms, room_count_total,
                        a_content_frequency,
                        content_solid_frequency)
  calculateContentProbability(a_rooms, room_count_total,
                              a_content_frequency)
  connectDisconnectedRooms(a_rooms, room_count_total)

  --
  --  6. Print out layout statistics
  --

  if PRINT_LAYOUT_STATISTICS then
    crawl.mpr("Layout Statistics (Square Ring)")
    crawl.mpr("  Depth: " .. depth)
    crawl.mpr("  Largest group: " .. getLargestGroup(a_group_frequency))
    local line = "  Frequencies:"
    for g = 0, ROOM_GROUP_COUNT - 1 do
      line = line .. "    " .. g .. ": " .. a_group_frequency[g]
    end
    line = line .. "    = " .. a_group_frequency.total
    crawl.mpr(line)
    crawl.mpr("  Total rooms: " .. room_count_total)
    crawl.mpr("  Total outside size: " .. size_total_per_side_outside)
    crawl.mpr("  Largest outside group: " .. group_largest_outside)
    line = "  Outer room groups:"
    for g = 0, ROOM_GROUP_COUNT - 1 do
      line = line .. "    " .. g .. ": " .. a_count_group_per_side_outside[g]
    end
    line = line .. "    = " .. size_total_per_side_outside
    line = line .. " / " .. size_maximum_outside
    for e = 0, FACING_DIRECTION_COUNT - 1 do
      local start_index = count_total_per_side_outside * e
      line = "  Outer rooms " .. e .. ":"
      for r = 0, count_total_per_side_outside - 1 do
        local index = start_index + r
        if a_rooms[index].m_is_dummy_wall then
          line = line .. "    X"
        else
          line = line .. "    " .. a_rooms[index].m_group
        end
      end
      crawl.mpr(line)
    end
    if is_extra_wall then
      crawl.mpr("  Extra wall: yes")
    else
      crawl.mpr("  Extra wall: no")
    end
    crawl.mpr("  Total inside size: " .. size_total_per_side_inside)
    crawl.mpr("  Inner corner rooms: " .. group_corner ..
              "  (" .. size_corner .. " x " .. size_corner .. ")")
    line = "  Inner room groups:"
    for g = 0, ROOM_GROUP_COUNT - 1 do
      line = line .. "    " .. g .. ": " .. a_count_group_per_side_inside[g]
    end
    line = line .. "    = " .. size_total_per_side_inside
    line = line .. " / " .. size_maximum_inside
    crawl.mpr(line)
    for e = 0, FACING_DIRECTION_COUNT - 1 do
      local start_index = count_total_per_side_outside *
                          FACING_DIRECTION_COUNT +
                          count_total_per_side_inside * e
      line = "  Inner rooms " .. e .. ":"
      for r = 0, count_total_per_side_inside - 1 do
        local index = start_index + r
        if a_rooms[index].m_is_dummy_wall then
          line = line .. "    X"
        else
          line = line .. "    " .. a_rooms[index].m_group
        end
      end
      crawl.mpr(line)
    end
    crawl.mpr("  Hallway size: " .. size_hallway ..
              " (min " .. size_hallway_minimum .. ")")
    crawl.mpr("  Hallway minus: [" .. hallway_minus_outside ..
              ", " .. hallway_minus_inside .. ")")
    crawl.mpr("  Hallway plus: [" .. hallway_plus_inside ..
              ", " .. hallway_plus_outside .. ")")
  end

  --
  --  7. Generate map
  --

  -- add square ring hallway
  e.fill_area{x1=hallway_minus_outside,
              y1=hallway_minus_outside,
              x2=(hallway_plus_outside - 1),
              y2=(hallway_plus_outside - 1),
              fill='.'}
  -- add the inside walls
  e.fill_area{x1=hallway_minus_inside,
              y1=hallway_minus_inside,
              x2=(hallway_plus_inside - 1),
              y2=(hallway_plus_inside - 1),
              fill='x'}

  -- add outside rooms
  for d = 0, FACING_DIRECTION_COUNT - 1 do
    local start_index = count_total_per_side_outside * d

    local along_pos = hallway_minus_outside
    for i = 0, count_total_per_side_outside - 1 do
      local index = start_index + i

      if a_rooms[index].m_is_dummy_wall then
        -- this is just an extra wall, no room needed
        along_pos = along_pos + 1
      else
        -- we want to add a real room

        local group = a_rooms[index].m_group
        local size = A_ROOM_SIZE[group]
        local connection = a_rooms[index].m_connection
        local facing = getSquareRingFacingDirection(d, connection)
        local is_room_attached = false
        if a_rooms[index].m_attached_count > 0 then
          is_room_attached = true
        end
        local content = a_rooms[index].m_content

        --
        --     2----->
        --  0 +-------+ 1
        --  | |*6--->*| |
        --  | |4     5| |
        --  | |v     v| |
        --  | |*7--->*| |
        --  v +-------+ v
        --     3----->
        --

        local x
        local y
        if d == FACING_X_MINUS then
          x = hallway_minus_outside - (size + 1)
          y = along_pos
        elseif d == FACING_X_PLUS then
          x = hallway_plus_outside + 1
          y = along_pos
        elseif d == FACING_Y_MINUS then
          x = along_pos
          y = hallway_minus_outside - (size + 1)
        else
          -- d == FACING_Y_PLUS
          x = along_pos
          y = hallway_plus_outside + 1
        end

        mapAddRoom(e, x, y, group, facing, is_room_attached, content)

        along_pos = along_pos + size + 1
      end
    end
  end

  -- add inner corners
  local corner_position_minus = hallway_minus_inside + 1
  local corner_position_plus  = hallway_plus_inside - (size_corner + 1)
  local is_room_attached

  is_room_attached = false
  if a_rooms[corner_index_xm_ym].m_attached_count > 0 then
    is_room_attached = true
  end
  mapAddRoom(e,
             corner_position_minus,
             corner_position_minus,
             a_rooms[corner_index_xm_ym].m_group,
             FACING_CORNER_XM_YM,
             is_room_attached,
             a_rooms[corner_index_xm_ym].m_content)

  is_room_attached = false
  if a_rooms[corner_index_xm_yp].m_attached_count > 0 then
    is_room_attached = true
  end
  mapAddRoom(e,
             corner_position_minus,
             corner_position_plus,
             a_rooms[corner_index_xm_yp].m_group,
             FACING_CORNER_XM_YP,
             is_room_attached,
             a_rooms[corner_index_xm_yp].m_content)

  is_room_attached = false
  if a_rooms[corner_index_xp_ym].m_attached_count > 0 then
    is_room_attached = true
  end
  mapAddRoom(e,
             corner_position_plus,
             corner_position_minus,
             a_rooms[corner_index_xp_ym].m_group,
             FACING_CORNER_XP_YM,
             is_room_attached,
             a_rooms[corner_index_xp_ym].m_content)

  is_room_attached = false
  if a_rooms[corner_index_xp_yp].m_attached_count > 0 then
    is_room_attached = true
  end
  mapAddRoom(e,
             corner_position_plus,
             corner_position_plus,
             a_rooms[corner_index_xp_yp].m_group,
             FACING_CORNER_XP_YP,
             is_room_attached,
             a_rooms[corner_index_xp_yp].m_content)

  -- add inside non-corner rooms
  for d = 0, FACING_DIRECTION_COUNT - 1 do
    local start_index = count_total_per_side_outside *
                        FACING_DIRECTION_COUNT +
                        count_total_per_side_inside * d

    local along_pos = hallway_minus_inside + size_corner + 2
    for i = 0, count_total_per_side_inside - 1 do
      local index = start_index + i

      if a_rooms[index].m_is_dummy_wall then
        -- this is just an extra wall, no room needed
        -- how did we get here, anyway?
        along_pos = along_pos + 1
      else
        -- we want to add a real room

        local group = a_rooms[index].m_group
        local size = A_ROOM_SIZE[group]
        local connection = a_rooms[index].m_connection
        local room_line_index = d + FACING_DIRECTION_COUNT
        local facing = getSquareRingFacingDirection(room_line_index, connection)
        local is_room_attached = false
        if a_rooms[index].m_attached_count > 0 then
          is_room_attached = true
        end
        local content = a_rooms[index].m_content

        --
        --     2----->
        --  0 +-------+ 1
        --  | |*6--->*| |
        --  | |4     5| |
        --  | |v     v| |
        --  | |*7--->*| |
        --  v +-------+ v
        --     3----->
        --

        local x
        local y
        if d == FACING_X_MINUS then
          x = hallway_minus_inside + 1
          y = along_pos
        elseif d == FACING_X_PLUS then
          x = hallway_plus_inside - (size + 1)
          y = along_pos
        elseif d == FACING_Y_MINUS then
          x = along_pos
          y = hallway_minus_inside + 1
        else
          -- d == FACING_Y_PLUS
          x = along_pos
          y = hallway_plus_inside - (size + 1)
        end

        mapAddRoom(e, x, y, group, facing, is_room_attached, content)

        along_pos = along_pos + size + 1
      end
    end
  end
end
}}



########
#
#  layoutSquareRingChaoticCity
#
#  Purpose: To generate a map with the rooms around a hallway
#       in the shape of a square ring and a chaotic city
#       inside.
#  Parameter(s):
#      <1> e: The global enviroment
#      <2> depth: The depth of the map within the branch
#      <3> a_group_frequency: The frequency of differant room
#                             groups
#      <4> a_content_frequency: The frequency of differant room
#                               content types
#      <5> content_solid_frequency: The frequency of a room
#                                   being filled with solid
#                                   wall
#      <6> a_entries: The content types for any branch or portal
#                     entries to add to the map
#  Preconditon(s):
#      <1> a_group_frequency != NULL
#      <2> a_group_frequency[ROOM_GROUP_TOTAL_FREQUENCY] > 0
#      <3> a_content_frequency != NULL
#      <4> a_entries != NULL
#  Returns: N/A
#  Side Effect: A map with hallways layout out around a square
#               ring with rooms outside and a chaotic city
#               inside is generated and printed to standard
#               output.  The map is layed out as specified by
#               a_group_frequency and a_content_frequency in a
#               manner appropriate for depth depth.
#

{{
function layoutSquareRingChaoticCity (e,
                                      depth,
                                      a_group_frequency,
                                      a_content_frequency,
                                      content_solid_frequency,
                                      a_entries)

  assert(a_group_frequency ~= nil,
         "a_group_frequency cannot == nil")
  assert(a_group_frequency.total > 0,
         "total frequency must be > 0")
  assert(a_content_frequency ~= nil,
         "a_content_frequency cannot == nil")
  assert(a_entries ~= nil, "a_entries cannot == nil")

  --
  --  1. Chose rooms for outside of hallway
  --
  --  All four sides of the ring have the same number of
  --    rooms in each group.  However, these order and
  --    content of these rooms is chosen randomly for each
  --    side.
  --
  --  Space must be left for a room of each side of the
  --    hallway and three walls between them.  That is one
  --    wall for each outside and one for the middle.  The
  --    other middle wall will be added with a room.
  --

  local group_largest_outside = getRandomGroupCorner(depth, a_group_frequency)
  if group_largest_outside == ROOM_GROUP_CLOSET then
    group_largest_outside = ROOM_GROUP_FIRST_NON_CLOSET
  end
  local size_largest_outside = A_ROOM_SIZE[group_largest_outside]

  local size_maximum_outside = getMaximumMapSize(depth) -
          (size_largest_outside * 2 + 3)

  local a_count_group_per_side = {}
  local size_total_per_side =
          calculateRoomsForLine(size_maximum_outside,
                                size_maximum_outside,
                                a_group_frequency,
                                group_largest_outside,
                                a_count_group_per_side,
                                true) - 1
  -- one wall is off the edge, so -1

  local count_total_per_side = getRoomCountTotal(a_count_group_per_side)

  -- if we did not get enough rooms, add some closets
  while count_total_per_side < 2 do
    a_count_group_per_side[ROOM_GROUP_CLOSET] =
            a_count_group_per_side[ROOM_GROUP_CLOSET] + 1
    size_total_per_side = size_total_per_side + 2
    count_total_per_side = count_total_per_side + 1
  end

  --
  --  2. Calculate hallway information
  --

  local size_hallway = getMinimumHallwaySize(depth)
  local hallway_minus_outside = size_largest_outside + 2
  local hallway_plus_outside  = hallway_minus_outside + size_total_per_side

  --
  --  3. Assign the outside rooms to positions
  --
  --  There are 4 lines of rooms to assign.
  --
  --  We also leave enough space in the array for the
  --    chaotic city rooms to be added to the center.
  --
  --     2----->
  --  0 +-------+ 1
  --  | |       | |
  --  | |       | |
  --  | |       | |
  --  | |       | |
  --  v +-------+ v
  --     3----->
  --

  local city_size = size_total_per_side - size_hallway * 2
  local total_city_area = city_size * city_size
  local room_city_attempts = math.floor(total_city_area *
                                        CHAOTIC_CITY_PLACE_ATTEMPTS_FACTOR)

  local first_city_room = count_total_per_side * FACING_DIRECTION_COUNT
  local room_count_total = first_city_room + room_city_attempts
  local a_rooms = {}

  -- outside of the square
  for d = 0, FACING_DIRECTION_COUNT - 1 do
    local start_index = count_total_per_side * d

    -- outside edges
    calculateRoomOrder(a_count_group_per_side,
                       false,
                       count_total_per_side,
                       a_rooms,
                       room_count_total,
                       start_index,
                       NO_ROOM,
                       NO_ROOM)
  end

  --
  --  4. Create city rooms
  --

  local city_position_min = 3 + size_largest_outside + size_hallway
  local city_position_max = city_position_min + city_size - 2
  local room_city_placed = calculateRoomsForChaoticCity(
                                   city_position_min, city_position_min,
                                   city_position_max, city_position_max,
                                   size_hallway,
                                   a_group_frequency,
                                   a_rooms,
                                   first_city_room,
                                   1,
                                   room_city_attempts)
  local room_count_used = first_city_room + room_city_placed

  --
  --  5. Assign room contents
  --

  calculateContentStairs(a_rooms, room_count_used,
                         depth)
  calculateContentBranchPortal(a_rooms, room_count_used,
                               a_entries)
  calculateContentSerialVault(a_rooms, room_count_used)
  calculateContentSolid(a_rooms, room_count_used,
                        a_content_frequency,
                        content_solid_frequency)
  calculateContentProbability(a_rooms, room_count_used,
                              a_content_frequency)
  connectDisconnectedRooms(a_rooms, room_count_used)

  --
  --  6. Print out layout statistics
  --

  if PRINT_LAYOUT_STATISTICS then
    crawl.mpr("Layout Statistics (Square Ring Chaotic City)")
    crawl.mpr("  Depth: " .. depth)
    crawl.mpr("  Largest group: " .. getLargestGroup(a_group_frequency))
    local line = "  Frequencies:"
    for g = 0, ROOM_GROUP_COUNT - 1 do
      line = line .. "    " .. g .. ": " .. a_group_frequency[g]
    end
    line = line .. "    = " .. a_group_frequency.total
    crawl.mpr(line)
    crawl.mpr("  Total rooms: " .. room_count_total)
    crawl.mpr("  Total outside size: " .. size_total_per_side)
    crawl.mpr("  Largest outside group: " .. group_largest_outside)
    line = "  Outer room groups:"
    for g = 0, ROOM_GROUP_COUNT - 1 do
      line = line .. "    " .. g .. ": " .. a_count_group_per_side[g]
    end
    line = line .. "    = " .. size_total_per_side
    line = line .. " / " .. size_maximum_outside
    crawl.mpr(line)
    for f = 0, FACING_DIRECTION_COUNT - 1 do
      local start_index = count_total_per_side * f
      line = "  Outer rooms " .. f .. ":"
      for r = 0, count_total_per_side - 1 do
        local index = start_index + r
        if a_rooms[index].m_is_dummy_wall then
          line = line .. "    X"
        else
          line = line .. "    " .. a_rooms[index].m_group
        end
      end
      crawl.mpr(line)
    end
    crawl.mpr("  Hallway size: " .. size_hallway)
    crawl.mpr("  Open area: [" .. hallway_minus_outside ..
              ", " .. hallway_plus_outside .. ")")
    crawl.mpr("  Total city rooms attempted: " .. room_city_attempts)
    crawl.mpr("  Total city rooms placed: " .. room_city_placed)
    crawl.mpr("  Position range for city rooms: [" ..
              city_position_min .. ", " .. city_position_max .. ")")
    line = "  Chaotic city rooms placed:"
    for r = 0, room_city_placed - 1 do
      local index = first_city_room + r
      line = line .. "    " .. a_rooms[index].m_group
    end
    crawl.mpr(line)
  end

  --
  --  7. Generate map
  --

  -- add open area including the ring hallway
  e.fill_area{x1=hallway_minus_outside,
              y1=hallway_minus_outside,
              x2=(hallway_plus_outside - 1),
              y2=(hallway_plus_outside - 1),
              fill='.'}

  -- add outside rooms
  for d = 0, FACING_DIRECTION_COUNT - 1 do
    local start_index = count_total_per_side * d

    local along_pos = hallway_minus_outside
    for i = 0, count_total_per_side - 1 do
      local index = start_index + i

      local group = a_rooms[index].m_group
      local size = A_ROOM_SIZE[group]
      local connection = a_rooms[index].m_connection
      local facing = getSquareRingFacingDirection(d, connection)
      local is_room_attached = false
      if a_rooms[index].m_attached_count > 0 then
        is_room_attached = true
      end
      local content = a_rooms[index].m_content

      --
      --     2----->
      --  0 +-------+ 1
      --  | |*6--->*| |
      --  | |4     5| |
      --  | |v     v| |
      --  | |*7--->*| |
      --  v +-------+ v
      --     3----->
      --

      local x
      local y
      if d == FACING_X_MINUS then
        x = hallway_minus_outside - (size + 1)
        y = along_pos
      elseif d == FACING_X_PLUS then
        x = hallway_plus_outside + 1
        y = along_pos
      elseif d == FACING_Y_MINUS then
        x = along_pos
        y = hallway_minus_outside - (size + 1)
      else
        -- d == FACING_Y_PLUS
        x = along_pos
        y = hallway_plus_outside + 1
      end

      mapAddRoom(e, x, y, group, facing, is_room_attached, content)

      along_pos = along_pos + size + 1
    end
  end

  -- add chaotic city rooms
  for r = 0, room_city_placed - 1 do
    local index = first_city_room + r

    local group = a_rooms[index].m_group
    local room_size = A_ROOM_SIZE[group]
    local content = a_rooms[index].m_content

    local x = a_rooms[index].m_x
    local y = a_rooms[index].m_y

    e.fill_area{x1=(x - 1),         y1=(y - 1),
                x2=(x + room_size), y2=(y + room_size),
                fill='x'}
    if a_rooms[index].m_connection == CONNECTION_NONE then
      mapAddRoom(e, x, y, group, FACING_NONE, false, content)
    else
      mapAddRoom(e, x, y, group, FACING_CITY, false, content)
    end
  end
end
}}



########
#
#  layoutSquareRingHugeCenter
#
#  Purpose: To generate a map with the rooms around a hallway
#       in the shape of a square ring around a huge center
#       room.
#  Parameter(s):
#      <1> e: The global enviroment
#      <2> depth: The depth of the map within the branch
#      <3> a_group_frequency: The frequency of differant room
#                             groups
#      <4> a_content_frequency: The frequency of differant room
#                               content types
#      <5> content_solid_frequency: The frequency of a room
#                                   being filled with solid
#                                   wall
#      <6> a_entries: The content types for any branch or portal
#                     entries to add to the map
#      <7> center_room_size_x
#      <8> center_room_size_y: The size of the center room
#  Preconditon(s):
#      <1> a_group_frequency != NULL
#      <2> a_group_frequency[ROOM_GROUP_TOTAL_FREQUENCY] > 0
#      <3> a_content_frequency != NULL
#      <4> a_entries != NULL
#      <5> center_room_size_x >= 1
#      <6> center_room_size_y >= 1
#  Returns: N/A
#  Side Effect: A map with hallways layout out around a square
#               ring with rooms outside and a huge center room
#               inside is generated and printed to standard
#               output.  The map is layed out as specified by
#               a_group_frequency and a_content_frequency in a
#               manner appropriate for depth depth.
#

{{
function layoutSquareRingHugeCenter (e,
                                     depth,
                                     a_group_frequency,
                                     a_content_frequency,
                                     content_solid_frequency,
                                     a_entries,
                                     center_room_size_x,
                                     center_room_size_y)

  assert(a_group_frequency ~= nil,
         "a_group_frequency cannot == nil")
  assert(a_group_frequency.total > 0,
         "total frequency must be > 0")
  assert(a_content_frequency ~= nil,
         "a_content_frequency cannot == nil")
  assert(a_entries ~= nil, "a_entries cannot == nil")
  assert(center_room_size_x >= 1, "center_room_size_x must be >= 1")
  assert(center_room_size_y >= 1, "center_room_size_y must be >= 1")

  --
  --  1. Chose maximum size for outside rooms
  --
  --  We start by picking a maximum group size.  If rooms
  --    of that group  would not fit, we try smaller
  --    groups until we find one that does.  This may
  --    result in rooms smaller than the smallest room
  --    group officially in use.  We also forbid closets
  --    as the maximum size because those maps look silly.
  --
  --  Across the map, space is needed for two hallways,
  --    two rooms, four walls, and the center room.  We
  --    also need 1 extra spot so that, if necessary, we
  --    can add a dummy wall to pad the size to an
  --    acceptible value.
  --

  local size_map_maximum = getMaximumMapSize(depth)
  local size_hallway_minimum = getMinimumHallwaySize(depth)

  local group_largest = getRandomGroupCorner(depth, a_group_frequency)
  if group_largest == ROOM_GROUP_CLOSET then
    group_largest = ROOM_GROUP_FIRST_NON_CLOSET
  end
  local size_largest = A_ROOM_SIZE[group_largest]

  -- reduce the size if x ot y dimension is too large
  local total_sides_size = size_hallway_minimum * 2 + size_largest * 2 + 4
  while center_room_size_x + total_sides_size + 1 > size_map_maximum or
        center_room_size_y + total_sides_size + 1 > size_map_maximum do
    group_largest = group_largest - 1
    size_largest = A_ROOM_SIZE[group_largest]
    total_sides_size = size_hallway_minimum * 2 + size_largest * 2 + 4
  end

  -- a special group frequency array containing only the largest group
  local a_group_frequency_largest = {}
  for g = 0, ROOM_GROUP_COUNT -1 do
    a_group_frequency_largest[g] = 0
  end
  a_group_frequency_largest[group_largest] = 1
  a_group_frequency_largest.total = 1

  --
  --  2. Chose rooms along Y-axis (left and right)
  --

  local side_length_minimum_y = center_room_size_y + size_hallway_minimum * 2

  local side_length_maximum_y = size_map_maximum - (size_largest * 2 + 3)
  if (side_length_maximum_y - side_length_minimum_y) % 2 ~= 0 then
    side_length_maximum_y = side_length_maximum_y - 1
  end

  local size_total_per_side_y
  local a_count_group_per_side_y = {}
  if a_group_frequency[group_largest] > 0 then
    -- chose rooms groups
    size_total_per_side_y = calculateRoomsForLine(
                                    side_length_minimum_y,
                                    side_length_maximum_y,
                                    a_group_frequency,
                                    group_largest,
                                    a_count_group_per_side_y,
                                    true) - 1
    -- one wall is off the edge, so -1
  else
    -- just pack in as many rooms of the non-standard size as possible
    size_total_per_side_y = calculateRoomsForLine(
                                    side_length_minimum_y,
                                    side_length_maximum_y,
                                    a_group_frequency_largest,
                                    group_largest,
                                    a_count_group_per_side_y,
                                    true) - 1
    -- one wall is off the edge, so -1
  end
  local count_total_per_side_y = getRoomCountTotal(a_count_group_per_side_y)

  -- add an extra wall if needed (closets add an even amount)
  local is_extra_wall_y = false
  -- total might be less than center room size
  if (size_total_per_side_y - center_room_size_y) % 2 ~= 0 then
    is_extra_wall_y = true
    count_total_per_side_y = count_total_per_side_y + 1
    size_total_per_side_y = size_total_per_side_y + 1
  end

  -- if needed, add closets until the line is big enough
  while size_total_per_side_y <= side_length_minimum_y - 2 do
    a_count_group_per_side_y[ROOM_GROUP_CLOSET] =
            a_count_group_per_side_y[ROOM_GROUP_CLOSET] + 1
    count_total_per_side_y = count_total_per_side_y + 1
    size_total_per_side_y = size_total_per_side_y +
                            A_ROOM_SIZE[ROOM_GROUP_CLOSET] + 1
  end

  local size_hallway_y = (size_total_per_side_y - center_room_size_y) / 2

  --
  --  3. Chose rooms along X-axis (top and bottom)
  --

  local side_length_minimum_x = center_room_size_x + size_hallway_minimum * 2

  local side_length_maximum_x = size_map_maximum - (size_largest * 2 + 3)
  if (side_length_maximum_x - side_length_minimum_x) % 2 ~= 0 then
    side_length_maximum_x = side_length_maximum_x - 1
  end

  local size_total_per_side_x
  local a_count_group_per_side_x = {}
  if a_group_frequency[group_largest] > 0 then
    -- chose rooms groups
    size_total_per_side_x = calculateRoomsForLine(
                                    side_length_minimum_x,
                                    side_length_maximum_x,
                                    a_group_frequency,
                                    group_largest,
                                    a_count_group_per_side_x,
                                    true) - 1
    -- one wall is off the edge, so -1
  else
    -- just pack in as many rooms of the non-standard size as possible
    size_total_per_side_x = calculateRoomsForLine(
                                    side_length_minimum_x,
                                    side_length_maximum_x,
                                    a_group_frequency_largest,
                                    group_largest,
                                    a_count_group_per_side_x,
                                    true) - 1
    -- one wall is off the edge, so -1
  end
  local count_total_per_side_x = getRoomCountTotal(a_count_group_per_side_x)

  -- add an extra wall if needed (closets add an even amount)
  local is_extra_wall_x = false
  -- total might be less than center room size
  if (size_total_per_side_x - center_room_size_x) % 2 ~= 0 then
    is_extra_wall_x = true
    count_total_per_side_x = count_total_per_side_x + 1
    size_total_per_side_x = size_total_per_side_x + 1
  end

  -- if needed, add closets until the line is big enough
  while size_total_per_side_x <= side_length_minimum_x - 2 do
    a_count_group_per_side_x[ROOM_GROUP_CLOSET] =
            a_count_group_per_side_x[ROOM_GROUP_CLOSET] + 1
    count_total_per_side_x = count_total_per_side_x + 1
    size_total_per_side_x = size_total_per_side_x +
                            A_ROOM_SIZE[ROOM_GROUP_CLOSET] + 1
  end

  local size_hallway_x = (size_total_per_side_x - center_room_size_x) / 2

  --
  --  4. Assign the rooms to positions
  --
  --  There are 4 lines of rooms to assign:
  --    -> 2 Y-axis lines
  --    -> 2 X-axis lines
  --
  --     2----->
  --  0 +-------+ 1
  --  | |       | |
  --  | |       | |
  --  | |       | |
  --  | |       | |
  --  v +-------+ v
  --     3----->
  --

  local first_room_x = count_total_per_side_y * 2
  local room_count_total = first_room_x + count_total_per_side_x * 2
  local a_rooms = {}

  -- Y edges
  for y = 0, 1 do
    local start_index = count_total_per_side_y * y

    calculateRoomOrder(a_count_group_per_side_y,
                       is_extra_wall_y,
                       count_total_per_side_y,
                       a_rooms,
                       room_count_total,
                       start_index,
                       NO_ROOM,
                       NO_ROOM)
  end

  -- X edges
  for x = 0, 1 do
    local start_index = first_room_x + count_total_per_side_x * x

    calculateRoomOrder(a_count_group_per_side_x,
                       is_extra_wall_x,
                       count_total_per_side_x,
                       a_rooms,
                       room_count_total,
                       start_index,
                       NO_ROOM,
                       NO_ROOM)
  end

  --
  --  5. Assign room contents
  --

  calculateContentStairs(a_rooms, room_count_total,
                         depth)
  calculateContentBranchPortal(a_rooms, room_count_total,
                               a_entries)
  calculateContentSerialVault(a_rooms, room_count_total)
  calculateContentSolid(a_rooms, room_count_total,
                        a_content_frequency,
                        content_solid_frequency)
  calculateContentProbability(a_rooms, room_count_total,
                              a_content_frequency)
  connectDisconnectedRooms(a_rooms, room_count_total)

  --
  --  6. Print out layout statistics
  --

  if PRINT_LAYOUT_STATISTICS then
    crawl.mpr("Layout Statistics (Square Ring Huge Center)")
    crawl.mpr("  Depth: " .. depth)
    crawl.mpr("  Largest group: " .. getLargestGroup(a_group_frequency))
    local line = "  Frequencies:"
    for g = 0, ROOM_GROUP_COUNT - 1 do
      line = line .. "    " .. g .. ": " .. a_group_frequency[g]
    end
    line = line .. "    = " .. a_group_frequency.total
    crawl.mpr(line)
    crawl.mpr("  Total rooms: " .. room_count_total)
    crawl.mpr("  Largest group: " .. group_largest)
    crawl.mpr("  Y-axis size range = [" .. side_length_minimum_y ..
              ", " .. side_length_maximum_y .. "]")
    line = "  Y-axis room groups:"
    for g = 0, ROOM_GROUP_COUNT - 1 do
      line = line .. "    " .. g .. ": " .. a_count_group_per_side_y[g]
    end
    line = line .. "    = " .. size_total_per_side_y
    line = line .. " / " .. side_length_maximum_y
    crawl.mpr(line)
    for y = 0, 1 do
      local start_index = count_total_per_side_y * y
      line = "  Y-axis rooms " .. y .. ":"
      for r = 0, count_total_per_side_y - 1 do
        local index = start_index + r
        if a_rooms[index].m_is_dummy_wall then
          line = line .. "    X"
        else
          line = line .. "    " .. a_rooms[index].m_group
        end
      end
      crawl.mpr(line)
    end
    crawl.mpr("  Hallway size y: " .. size_hallway_y)
    crawl.mpr("  X-axis size range = [" .. side_length_minimum_x ..
              ", " .. side_length_maximum_x .. "]")
    line = "  X-axis room groups:"
    for g = 0, ROOM_GROUP_COUNT - 1 do
      line = line .. "    " .. g .. ": " .. a_count_group_per_side_x[g]
    end
    line = line .. "    = " .. size_total_per_side_x
    line = line .. " / " .. side_length_maximum_x
    crawl.mpr(line)
    for x = 0, 1 do
      local start_index = first_room_x + count_total_per_side_x * x
      line = "  X-axis rooms " .. x .. ":"
      for r = 0, count_total_per_side_y - 1 do
        local index = start_index + r
        if a_rooms[index].m_is_dummy_wall then
          line = line .. "    X"
        else
          line = line .. "    " .. a_rooms[index].m_group
        end
      end
      crawl.mpr(line)
    end
    crawl.mpr("  Hallway size x: " .. size_hallway_x)
  end

  --
  --  7. Generate map
  --

  local hallway_minus_x = size_largest + 2
  local hallway_plus_x  = hallway_minus_x + size_total_per_side_x
  local hallway_minus_y = size_largest + 2
  local hallway_plus_y  = hallway_minus_y + size_total_per_side_y

  -- add the hallway
  e.fill_area{x1=hallway_minus_x,
              y1=hallway_minus_y,
              x2=(hallway_plus_x - 1),
              y2=(hallway_plus_y - 1),
              fill='.'}

  -- add the huge central room
  local center_min_x = hallway_minus_x + size_hallway_x
  local center_min_y = hallway_minus_y + size_hallway_y
  local center_max_x = center_min_x + center_room_size_x
  local center_max_y = center_min_y + center_room_size_y
  e.fill_area{x1=center_min_x,       y1=center_min_y,
              x2=(center_max_x - 1), y2=(center_max_y - 1),
              fill='A'}
  e.subvault("A : vaults_room_huge_" .. center_room_size_x ..
             "x" .. center_room_size_y)
  -- just to be safe...
  e.subst("A : .")

  -- add rooms parallel to the Y-axis
  for y = 0, 1 do
    local start_index = count_total_per_side_y * y

    local y_pos = hallway_minus_y
    for i = 0, count_total_per_side_y -1 do
      local index = start_index + i

      if a_rooms[index].m_is_dummy_wall then
        -- we just want an extra cell of wall, not a room
        y_pos = y_pos + 1
      else
        -- this is a real room

        local group = a_rooms[index].m_group
        local size = A_ROOM_SIZE[group]
        local connection = a_rooms[index].m_connection
        local is_room_attached = false
        if a_rooms[index].m_attached_count > 0 then
          is_room_attached = true
        end
        local content = a_rooms[index].m_content

        --
        --     2----->
        --  0 +-------+ 1
        --  | |       | |
        --  | |       | |
        --  | |       | |
        --  | |       | |
        --  v +-------+ v
        --     3----->
        --

        local x_pos
        local facing
        if y == 0 then
          x_pos = hallway_minus_x - (size + 1)
          facing = getSquareRingFacingDirection(0, connection)
        else
          -- y == 1
          x_pos = hallway_plus_x + 1
          facing = getSquareRingFacingDirection(1, connection)
        end

        mapAddRoom(e, x_pos, y_pos, group, facing, is_room_attached, content)

        y_pos = y_pos + size + 1
      end
    end
  end

  -- add rooms parallel to the X-axis
  for x = 0, 1 do
    local start_index = first_room_x + count_total_per_side_x * x

    local x_pos = hallway_minus_x
    for i = 0, count_total_per_side_x -1 do
      local index = start_index + i

      if a_rooms[index].m_is_dummy_wall then
        -- we just want an extra cell of wall, not a room
        x_pos = x_pos + 1
      else
        -- this is a real room

        local group = a_rooms[index].m_group
        local size = A_ROOM_SIZE[group]
        local connection = a_rooms[index].m_connection
        local is_room_attached = false
        if a_rooms[index].m_attached_count > 0 then
          is_room_attached = true
        end
        local content = a_rooms[index].m_content

        --
        --     2----->
        --  0 +-------+ 1
        --  | |       | |
        --  | |       | |
        --  | |       | |
        --  | |       | |
        --  v +-------+ v
        --     3----->
        --

        local y_pos
        local facing
        if x == 0 then
          y_pos = hallway_minus_y - (size + 1)
          facing = getSquareRingFacingDirection(2, connection)
        else
          -- x == 1
          y_pos = hallway_plus_y + 1
          facing = getSquareRingFacingDirection(3, connection)
        end

        mapAddRoom(e, x_pos, y_pos, group, facing, is_room_attached, content)

        x_pos = x_pos + size + 1
      end
    end
  end
end
}}





################################################################################
#  Layouts
#
#  These are the layouts themselves.
#

default-depth: Vaults



########
#  layout_vaults_test
#
#  This is a dummy layout for test purposes.  It prints the
#    room frequencies and builds a big open level.
#

NAME:    layout_vaults_test
DEPTH:   Vaults
WEIGHT:  0
ORIENT:  encompass
TAGS:    overwritable layout allow_dup unrand
{{
  extend_map{width = MAP_SIZE, height = MAP_SIZE, fill = 'x'}

  layout_type ""

  fill_area{x1=10, y1=10, x2=60, y2=60, fill='.'}

  for style = 0, 2 do
    crawl.mpr("+-------------------------------------------------------+\r")
    if style == 0 then
      crawl.mpr("|          Constant Room Frequencies by Depth           |\r")
    elseif style == 1 then
      crawl.mpr("|          Variable Room Frequencies by Depth           |\r")
    elseif style == 2 then
      crawl.mpr("|         Scrambled Room Frequencies by Depth           |\r")
    end
    crawl.mpr("+-------+-------+-------+-------+-------+-------+-------+\r")
    crawl.mpr("| depth |  1x1  |  4x4  |  7x7  | 10x10 | 15x15 | total |\r")
    crawl.mpr("+-------+-------+-------+-------+-------+-------+-------+\r")

    for d = 1, dgn.br_depth(you.branch()) - 1 do
      local a_group_frequency = {}
      a_group_frequency.total = 0

      if style == 0 then
        setGroupFrequencyConstant(d, a_group_frequency)
      elseif style == 1 then
        setGroupFrequencyVariable(d, a_group_frequency)
      elseif style == 2 then
        setGroupFrequencyScrambled(d, a_group_frequency)
      end

      local line = "| " .. d
      for i = 0, ROOM_GROUP_COUNT - 1 do
        line = line .. "     | " .. a_group_frequency[i]
      end
      line = line .. "     | " .. a_group_frequency.total .. "     |\r"
      crawl.mpr(line)
    end

    crawl.mpr("+-------+-------+-------+-------+-------+-------+-------+\r")
    crawl.mpr("\r")
  end
}}
MAP
ENDMAP


########
#  layout_vaults
#
#  This is the one and only layout.  There is only one so that
#    the frequencies of different map types can vary by depth.
#
#  This layout intentially does not set the overwritable tag.
#    Some of these layouts are easily damaged by overwiting
#    portions, and they already have subvaults to give them a
#    lot of variety.
#

NAME:    layout_vaults
DEPTH:   Vaults
CHANCE:  100%
ORIENT:  encompass
TAGS:    layout allow_dup unrand
{{
  extend_map{width = MAP_SIZE, height = MAP_SIZE, fill = 'x'}

  -- no vaults appear on this map anyway, so who cares?
  layout_type "vaults"

  -- this is the depth in the current branch
  local depth = you.depth()

  local layout_style
  local room_group_style

  layout_style, room_group_style = getStyle(depth)

  -- crawl.mpr("depth fraction = " .. getDepthFraction(depth))
  -- crawl.mpr("layout_style = " .. layout_style)
  -- crawl.mpr("room_group_style = " .. room_group_style)

  local a_group_frequency
  if room_group_style == ROOM_GROUP_STYLE_CONSTANT then
    a_group_frequency = getGroupFrequencyArrayConstant(depth)
  elseif room_group_style == ROOM_GROUP_STYLE_VARIABLE then
    a_group_frequency = getGroupFrequencyArrayVariable(depth)
  else
    -- room_group_style == ROOM_GROUP_STYLE_SCRAMBLED
    a_group_frequency = getGroupFrequencyArrayScrambled(depth)
  end

  if layout_style == LAYOUT_STYLE_CITY then

    local size_group = getRandomGroup(a_group_frequency)
    if size_group == ROOM_GROUP_CLOSET then
      size_group = ROOM_GROUP_FIRST_NON_CLOSET
    end

    local a_content_frequency = getContentFrequencyArray()
    a_content_frequency[CONTENT_VANISH] = CONTENT_VANISH_FREQUENCY_CITY

    layoutCity (_G,
                depth,
                size_group,
                a_content_frequency,
                CONTENT_SOLID_FREQUENCY_CITY,
                getEntries(depth))

  elseif layout_style == LAYOUT_STYLE_CHAOTIC_CITY then

    layoutChaoticCity (_G,
                       depth,
                       a_group_frequency,
                       getContentFrequencyArray(),
                       CONTENT_SOLID_FREQUENCY_CHAOTIC_CITY,
                       getEntries(depth))

  elseif layout_style == LAYOUT_STYLE_GRID then

    local size_group = getRandomGroup(a_group_frequency)
    if size_group == ROOM_GROUP_CLOSET then
      size_group = ROOM_GROUP_FIRST_NON_CLOSET
    end

    layoutMaze (_G,
                depth,
                size_group,
                getContentFrequencyArray(),
                A_CONTENT_SOLID_FREQUENCY_GRID[size_group],
                BRANCH_FACTOR_GRID,
                EXTRA_CONNECTION_PERCENT_GRID,
                getEntries(depth))

  elseif layout_style == LAYOUT_STYLE_MAZE then

    local size_group = getRandomGroup(a_group_frequency)
    if size_group == ROOM_GROUP_CLOSET then
      size_group = ROOM_GROUP_FIRST_NON_CLOSET
    end

    local a_content_frequency = getContentFrequencyArray()
    a_content_frequency[CONTENT_HALLWAY] =
                    A_CONTENT_HALLWAY_FREQUENCY_MAZE[size_group]

    layoutMaze (_G,
                depth,
                size_group,
                a_content_frequency,
                A_CONTENT_SOLID_FREQUENCY_MAZE[size_group],
                BRANCH_FACTOR_MAZE,
                EXTRA_CONNECTION_PERCENT_MAZE,
                getEntries(depth))

  elseif layout_style == LAYOUT_STYLE_CROSS then

    layoutCross (_G,
                 depth,
                 a_group_frequency,
                 getContentFrequencyArray(),
                 CONTENT_SOLID_FREQUENCY_CROSS,
                 getEntries(depth))

  elseif layout_style == LAYOUT_STYLE_WALKWAYS then

    layoutWalkways (_G,
                    depth,
                    a_group_frequency,
                    getContentFrequencyArray(),
                    getContentSolidFrequencyWalkways(a_group_frequency),
                    getEntries(depth))

  elseif layout_style == LAYOUT_STYLE_SQUARE_RING then

    layoutSquareRing (_G,
                      depth,
                      a_group_frequency,
                      getContentFrequencyArray(),
                      CONTENT_SOLID_FREQUENCY_SQUARE_RING,
                      getEntries(depth))

  elseif layout_style == LAYOUT_STYLE_SQUARE_RING_CHAOTIC_CITY then

    layoutSquareRingChaoticCity (
            _G,
            depth,
            a_group_frequency,
            getContentFrequencyArray(),
            CONTENT_SOLID_FREQUENCY_SQUARE_RING_CHAOTIC_CITY,
            getEntries(depth))

  elseif layout_style == LAYOUT_STYLE_SQUARE_RING_HUGE_CENTER then

    local size_x
    local size_y

    size_x, size_y = getHugeCenterSize(depth)

    layoutSquareRingHugeCenter (
            _G,
            depth,
            a_group_frequency,
            getContentFrequencyArray(),
            CONTENT_SOLID_FREQUENCY_SQUARE_RING_HUGE_CENTER,
            getEntries(depth),
            size_x,
            size_y)
  else
    crawl.mpr("Illegal layout style " .. layout_style)
    -- regenerate map
  end
}}
MAP
ENDMAP
