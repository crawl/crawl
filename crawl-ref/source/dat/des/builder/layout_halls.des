###############################################################################
# layout_caves.des: Layouts based on cavelike formations, largely using
#                   procedural noise functions
###############################################################################

: require("dlua/util.lua")
: require("dlua/layout/procedural.lua")
: require("dlua/layout/procedural_primitives.lua")
: require("dlua/layout/procedural_complex.lua")
: require("dlua/layout/zonify.lua")

{{

  local onion_weights = {
    -- TODO: More shapes are possible; triangle, oval, rectangle, elongated circle,
    -- actually a generic polygon covers the triangle case, maybe irregular polygons,
    -- stars,
    { weight = 10, func = function() return primitive.distance end },
    { weight = 10, func = function() return primitive.box end },
    { weight = 10, func = function() return primitive.diamond() end },
    { weight = 10, func = function() return primitive.octagon(0.25) end },
    { weight = 10, func = function() return primitive.hexagon(0.25) end },
    -- ex did produce some interesting stuff but it's not ideal
    -- { weight = 10, func = function() return primitive.ex() end },
  }

  -- Generates the main onion function
  function onion_skin(num_rings,wall_break)
    local chosen = util.random_weighted_from("weight",onion_weights)
    local fcircle = chosen.func()

    -- Make holes in each partitioning wall
    local rings = {}
    local hole_size = util.random_range_real(0.1,0.3) -- 0.6

    -- TODO: There are some other functions that could be used to carve holes; e.g. spirals, worley ...
    local phasering = function(size)
      local num = crawl.random_range(5*size,20*size) + 1
      return procedural.phase(primitive.radial,crawl.random_range(2,10),crawl.random_real())
    end

    local randomring = function(size)
      local p = 0
    end

    for n=1,num_rings-1,1 do
      rings[n] = phasering(n/num_rings)
    end

    -- Do we create a central room?
    local fill_center = crawl.coinflip()

    local fphase = function(x,y)
      local r = fcircle(x,y)
      if r >= 1 then return 0 end
      local rr = r * num_rings
      local level = math.floor(rr)
      r = rr - level
      if fill_center and level == 0 then return 1 end

      -- Fill connecting walls?
      if level > 0 and r <= wall_break then
        local hole = rings[level]
        if hole ~= nil then
          return hole(x,y)
        end
      end

      return r
    end

    return fphase
  end

}}

NAME:   layout_hall_layers
DEPTH:  D:2-,Zot,Lair,Elf
WEIGHT: 5, 10 (Zot), 5 (Lair), 20 (Elf)
ORIENT: encompass
TAGS: overwritable layout allow_dup unrand
{{
  layout_type "halls"
  if is_validating() then return; end
  local gxm,gym = dgn.max_bounds()

  -- Actual corridor width will be double this; it gets increased later
  -- but it needs to be declared here so it's in scope for the callbacks
  local width = 1

  -- TODO:
  -- * More interesting primary shape options
  -- * One or two more layers would be nice, or separating things into separate
  --   groups of stuff since there are a lot of shapes here and they don't always work well together
  -- * Make some layers optional
  -- * Negative space
  -- * Invert floor and use interference between layers

  -- A big shape that should span the entire level to make sure everything is connected
  local shapes1 = {
    { weight = 10, func = primitive.cross },
    { weight = 3, func = primitive.ex },
    { weight = 10, func = function() return procedural.mul(crawl.random_range(4,8),procedural.sub(primitive.distance,primitive.box)) end },
    -- Rays
    { weight = 5, func = function() return procedural.mul(width*8,procedural.phase(primitive.radial, crawl.random_range(4,8), crawl.random_real())) end },
  }

  -- A medium sized shape that circles the level
  local shapes2 = {
    { weight = 10, func = function() return primitive.ring(gym/3) end },
    { weight = 10, func = function() return primitive.ringify(primitive.box,gym/3) end },
    { weight = 10, func = function() return primitive.ringify(primitive.diamond(),2/5*gym) end },
    { weight = 10, func = function() return primitive.ringify(primitive.octagon(crawl.random_range(5,20)),gym/3) end },
    { weight = 10, func = function() return primitive.ringify(primitive.hexagon(crawl.random_range(5,15)),gym/3) end },
    { weight = 10, func = function() return procedural.mul(1.8,primitive.ringify(procedural.scale(primitive.triangle(),1,2),gym/6)) end },
    { weight = 10, func = function() return procedural.mul(width, procedural.map(procedural.scale(complex.cog(
        crawl.random_range(10,30), -- Teeth
        util.random_range_real(0.7,0.9), -- Inner distance
        util.random_range_real(0.3,0.6), -- Gap between teeth
        util.random_range_real(0,1)      -- Offset (TODO: Fix how the procedural works so we can align at 0 or 0.5 for symmettry)
        ),gym*4/9),{ { 0,0.9,2,2 }, { 0.9,1,0.9,1 } })) end },
  }

  -- Smaller shapes to fit in the middle
  function scale_or_ring(prim, size)
    if crawl.one_chance_in(3) then
      -- Larger central shape
      return procedural.scale(prim,2)
    elseif crawl.coinflip() then
      -- Small ring
      return primitive.ringify(prim,size/2)
    elseif crawl.one_chance_in(8) then
      -- Very rarely don't actually scale it - it's quite interesting when
      -- e.g. circle and diamond overlap at the same size.
      return primitive.ringify(prim,size)
    else
      -- Small ring w/narrower corridors
      return procedural.scale(primitive.ringify(prim,size),.5)
    end
  end

  local shapes3 = {
    { weight = 10, func = function() return scale_or_ring(primitive.distance,gym/3) end },
    { weight = 10, func = function() return scale_or_ring(primitive.box,gym/3) end },
    { weight = 10, func = function() return scale_or_ring(primitive.octagon(crawl.random_range(4,8)),gym/3) end },
    { weight = 10, func = function() return scale_or_ring(primitive.hexagon(crawl.random_range(4,8)),gym/3) end },
    { weight = 10, func = function() return scale_or_ring(procedural.scale(primitive.triangle(),1,2),gym/6) end },
    { weight = 10, func = function() return scale_or_ring(primitive.diamond(),2/5*gym) end },
    { weight = 10, func = function() return procedural.scale(primitive.ex(),.5) end },
    { weight = 10, func = function() return primitive.ringify(primitive.ex(),crawl.random_range(gym/6,gym/4)) end },
    { weight = 10, func = function() return primitive.ringify(primitive.cross(),crawl.random_range(gym/6,gym/4)) end },
    { weight = 10, func = function() return procedural.mul(crawl.random_range(2,4),primitive.ringify(procedural.sub(primitive.distance,primitive.box),6)) end },
    { weight = 10, func = function() return procedural.mul(width, procedural.scale(complex.cog(
        crawl.random_range(3,8)*2, -- Teeth
        util.random_range_real(0.1,0.9), -- Inner distance
        util.random_range_real(0.4,0.6), -- Gap between teeth
        util.random_range_real(0,1)      -- Offset (TODO: Fix how the procedural works so we can align at 0 or 0.5 for symmettry)
        ),gym/4)) end },
    -- Spiral -- this didn't work too well as a primary function, but it looks awesome
    -- when overlaid with a second-level gear. It'd be nice to make it able to overlay
    -- with both gears on those extremely rare occasions.
    -- TODO: Actually there should be a completely separate layout with spiral + cogs, maybe Dis
    { weight = 10, func = function()
                            local rot = crawl.random_range(5,20)
                            return function(x,y)
                              local r = primitive.radial(x,y)
                              local d = primitive.distance(x,y)
                              if d > gym/2 then return width end
                              return (r + d/rot)%1 * width * rot * .4
                            end
                          end
    },
  }

  local cave = you.in_branch("D") and crawl.coinflip()
               or you.in_branch("Lair") and crawl.x_chance_in_y(2,3)

  if cave then
    width = crawl.random_range(4,6)
  else
    width = crawl.random_range(2,3)
  end

  local s1 = util.random_weighted_from("weight",shapes1)
  local s2 = util.random_weighted_from("weight",shapes2)
  local s3 = util.random_weighted_from("weight",shapes3)

  local func = procedural.translate(
    procedural.min(
      s1.func(),
      s2.func(),
      s3.func()
    ),
    gxm/2,gym/2
  )

  func = procedural.map(func,width/2,width,0,1)

  if cave then
    func = procedural.add(func,procedural.worley_diff{scale=.5})
  end

  -- TODO: Package the func(s) into room generators. Then place them using hyper (with a
  -- symetrically padded placement strategy). Then optionally outline with transparent
  -- stone and surround in lava like old crosses layout

  procedural.render_map(_G, func, function(v) return (v < 1 and '.' or 'x') end)
  zonify.map_fill_zones(_G, 1, 'x')

}}
MAP
ENDMAP

# Takes one of the primitive shapes and creates nested corridors in that
# shape, somewhat like an onion. Carves randomly spaced gaps in the walls
# to connect everything up.
NAME:   layout_onion
DEPTH:  Zot,Snake
WEIGHT: 20
ORIENT: encompass
TAGS: overwritable layout allow_dup unrand
{{
  layout_type "halls"
  if is_validating() then return; end
  local gxm,gym = dgn.max_bounds()

  -- TODO:
  --  * Implement chaotic gaps sizing
  --  * Maybe ruin some walls
  --  * Tune params a bit for Snake

  local wall_break = util.random_range_real(.4,.7)

  -- Make the rings
  local num_rings = crawl.random2avg(7,2)+2
  local fphase = onion_skin(num_rings,wall_break)

  -- Position on map
  fphase = procedural.translate(procedural.scale(fphase,math.min(gxm,gym)/2-2),gxm/2,gym/2)

  if you.in_branch("Snake") then
    -- Apply distortion
    -- TODO: This whole distortion function is pretty awesome and needs to be in a library
    local fdsx = procedural.simplex3d { scale = util.random_range_real(0.1,1), unit = false }
    local fdsy = procedural.simplex3d { scale = util.random_range_real(0.1,1), unit = false }
    -- Distort more at the edge of the map
    -- TODO: Will work even better with a less linear easing function
    local fbox = procedural.box{}
    local fedge = function(x,y)
      return math.max(0,1-fbox(x,y))
    end
    local fdx = procedural.mul(fdsx,fedge)
    local fdy = procedural.mul(fdsy,fedge)

    fphase = procedural.distort { source = fphase, scale = crawl.random_range(4,8), offsetx = fdx, offsety = fdy }
  end

  procedural.render_map(_G, fphase, function(v) return (v > wall_break and '.' or 'x') end)

  zonify.map_fill_zones(_G, 1, 'x')
}}
MAP
ENDMAP

# Takes an inverted version of the onion layout so what were walls
# are now rooms - connects these up with a noise pattern.
# Hopefully this should look like ancient abandoned catacombs.
# TODO: Other ways of connecting up the rooms.
NAME:   layout_catacombs
DEPTH:  Crypt
WEIGHT: 0
ORIENT: encompass
TAGS: overwritable layout allow_dup unrand
{{
  layout_type "halls"
  if is_validating() then return; end
  local gxm,gym = dgn.max_bounds()

  -- Make the rings
  local num_rings = crawl.random2avg(6,2)+4
  local wall_break = util.random_range_real(.5,.8)
  local fphase = onion_skin(num_rings,wall_break)

  -- Position on map
  fphase = procedural.translate(procedural.scale(fphase,math.min(gxm,gym)/2-2),gxm/2,gym/2)

  -- Do the render
  procedural.render_map(_G, fphase, function(v) return (v < wall_break and '.' or 'x') end)
  procedural.render_map(_G, procedural.worley_diff{scale=util.random_range_real(0.1,0.2) }, function(v) return (v < 0.1 and '.' or nil) end)

  zonify.map_fill_zones(_G, 1, 'x')
}}

# Layers two onions on top of each other to create an
# interference pattern (with option xor)
NAME:   layout_onion_interference
DEPTH:  Zot:1-4,Snake
WEIGHT: 0
ORIENT: encompass
TAGS: overwritable layout allow_dup unrand
{{

  -- TODO: This comes out with really stunning layouts 80% of the time
  -- but sometimes they're small and weird-looking. Needs more tweaking.
  -- Ideas:
  --  * Convert to use the other shape functions
  --  * Layer different shapes instead of the same two

  layout_type "halls"
  if is_validating() then return; end
  local gxm,gym = dgn.max_bounds()

  local fcircle
  if crawl.coinflip() then
    fcircle = procedural.distance { radius = math.min(gxm,gym)/2.2 - 2, origin = { x = gxm/2, y = gym/2 } }
  else
    local padx,pady = crawl.random_range(2,5),crawl.random_range(2,5)
    fcircle = procedural.box { x1 = padx, y1 = pady, x2 = gxm-1-padx, y2 = gym-1-pady }
  end

  local wall_break = util.random_range_real(.4,.6)
  local rings = crawl.random_range(5,8)

  local fill_center = crawl.coinflip()
  local frings = function(x,y)
    local r = fcircle(x,y)
    if r >= 1 then return -1 end
    local rr = r * rings
    local level = math.floor(rr)
    r = rr - level
    if fill_center and level == 0 then return 1 end
    return r
  end

  if you.in_branch("Snake") then

    -- Apply distortion
    local fdsx = procedural.simplex3d { scale = util.random_range_real(0.1,1), unit = false }
    local fdsy = procedural.simplex3d { scale = util.random_range_real(0.1,1), unit = false }
    -- Distort more at the edge of the map
    local fbox = procedural.box{}
    local fedge = function(x,y)
      return math.max(0,1-fbox(x,y))
    end
    local fdx = procedural.mul(fdsx,fedge)
    local fdy = procedural.mul(fdsy,fedge)

    frings = procedural.distort { source = frings, scale = crawl.random_range(5,15), offsetx = fdx, offsety = fdy }

  end

  -- Generate the interference pattern by combining two coords
  -- from the original func
  local cardinal = crawl.coinflip()
  local basedirs
  if cardinal then
    basedirs = vector.diagonals
  else
    basedirs = {}
    local dir = { x = util.random_range_real(0.5,1), y = util.random_range_real(0.5,1) }
    for n=1,4,1 do
      basedirs[n] = { x = vector.diagonals[n].x*dir.x, y = vector.diagonals[n].y*dir.y }
    end
  end

  local dist = crawl.random_range(3,6)
  local dirs = {}
  for n=1,4,1 do
    dirs[n] = { x = basedirs[n].x*dist, y = basedirs[n].y*dist }
  end

  local xor = crawl.coinflip()

  local vals = {}
  local fvals = function(x,y)
    for n=1,4,1 do
      vals[n] = frings(x+dirs[n].x,y+dirs[n].y)
    end
    return vals
  end

  local fphase
  local two_or_four = crawl.coinflip()
  if xor then
    fphase = function(x,y)
      local vals = fvals(x,y)
      if two_or_four then
        if vals[1] < 0 or vals[2] < 0 or vals[3] < 0 or vals[4] < 0 then return 0 end
        if vals[1] > wall_break and vals[2] > wall_break or vals[3] > wall_break and vals[4] > wall_break then
          return vals[1] - vals[2] + vals[3] - vals[4]
        end
      else
        if vals[1] < 0 or vals[3] < 0 then return 0 end
        if vals[1] > wall_break and vals[3] > wall_break then
          return vals[1] - vals[3]
        end
      end
      return 1
    end
  else
    fphase = function(x,y)
      local vals = fvals(x,y)
      if two_or_four then
        if vals[1] < 0 or vals[2] < 0 or vals[3] < 0 or vals[4] < 0 then return 0 end
        return math.max(vals[1],vals[2],vals[3],vals[4])
      else
        if vals[1] < 0 or vals[3] < 0 then return 0 end
        return math.max(vals[1],vals[3])
      end
    end
  end

  procedural.render_map(_G, fphase, function(v) return (v > wall_break and '.' or 'x') end)

  zonify.map_fill_zones(_G, 1, 'x')
}}
MAP
ENDMAP
