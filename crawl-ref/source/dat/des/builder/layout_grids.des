###############################################################################
# layout_grids.des: Layouts based on grid structures generated by omnigrid
###############################################################################

: require("dlua/util.lua")
: require("dlua/layout/procedural.lua")
: require("dlua/layout/zonify.lua")
: require("dlua/layout/hyper.lua")
: require("dlua/layout/omnigrid.lua")

{{

  -- Draws a floor plan based on omnigrid
  function hyper.floors.floor_plan_omnigrid(room,options,gen)

    local paint = omnigrid.omnigrid_paint{
      guaranteed_divides = 0,
      subdivide_initial_chance = 80,  -- 20% chance of a donut
      fill_chance = 100,
      corridor_width = 8,
      minimum_size = 12,
      jitter = true,
      jitter_min = -2,
      jitter_max = 2,
      outer_corridor = true,
      size = room.size,
      paint_func = crawl.one_chance_in(3) and hyper.floors.cave_paint or nil,
      floor_func = crawl.one_chance_in(2) and hyper.floors.cave_paint or nil
    }
    return paint
  end

  function hyper.floors.floor_plan_finegrid(room,options,gen)
    local corridor_width = crawl.random_range(1,3)
    local jitters = {
      { weight = 20, jitter = false },
      { weight = 10, jitter = true, jitter_min = -3, jitter_max = 0 },
      -- With high jitter, it turns into really chaotic random architecture
      { weight = 5, jitter = true, jitter_min = -2, jitter_max = 1 },
      { weight = 5, jitter = true, jitter_min = -2, jitter_max = 2 }
    }
    local chosen = util.random_weighted_from("weight",jitters)

    local paint = omnigrid.omnigrid_paint{
      guaranteed_divides = 6,
      subdivide_initial_chance = 100,  -- 20% chance of a donut
      subdivide_level_multiplier = 0.98,
      corridor_width = corridor_width,
      fill_chance = 80,
      minimum_size = 6,
      jitter = chosen.jitter,
      jitter_min = chosen.jitter_min,
      jitter_max = chosen.jitter_max,
      size = room.size,
      paint_func = crawl.one_chance_in(3) and hyper.floors.cave_paint or nil,
      floor_func = crawl.one_chance_in(3) and hyper.floors.cave_paint or nil
    }
    return paint
  end

  function hyper.floors.floor_plan_microgrid(room,options,gen)
    local paint = omnigrid.omnigrid_paint{
      guaranteed_divides = 5,
      subdivide_initial_chance = 100,  -- 20% chance of a donut
      subdivide_level_multiplier = util.random_range_real(0.9,0.999),
      corridor_width = 1,
      fill_chance = crawl.random_range(50,90),
      minimum_size = 2,
      jitter = false,
      size = room.size,
      paint_func = crawl.one_chance_in(5) and hyper.floors.cave_paint or nil,
      floor_func = crawl.one_chance_in(4) and hyper.floors.cave_paint or nil
    }
    return paint
  end

}}

# Generates up to 3 grids of different granularities, then layers
# then on top of each other. At its simplest reduction this looks like
# forbidden_donut but with a randomly-placed hole. At its most complex
# it does all kinds of interesting things.
NAME: layout_layered_grid
DEPTH:  D, Zot, Elf, Crypt, Snake, Dis, Lair
WEIGHT: 20000
ORIENT: encompass
TAGS: overwritable layout allow_dup unrand no_rotate no_pool_fixup no_hmirror no_vmirror chance_d
{{
  if is_validating() then return; end

  local weights = {
    { weight = 20, primary = hyper.floors.floor_plan_omnigrid },
    { weight = 30, primary = hyper.floors.floor_plan_finegrid },
    { weight = 50, primary = hyper.floors.floor_plan_microgrid },
    { weight = 10, primary = hyper.floors.floor_plan_omnigrid, secondary = hyper.floors.floor_plan_finegrid },
    { weight = 10, primary = hyper.floors.floor_plan_omnigrid, secondary = hyper.floors.floor_plan_microgrid },
    { weight = 10, primary = hyper.floors.floor_plan_finegrid, secondary = hyper.floors.floor_plan_microgrid },
    -- Very rare because it's somewhat liable to end up as a big mostly empty room
    { weight = 5, primary = hyper.floors.floor_plan_omnigrid, secondary = hyper.floors.floor_plan_finegrid, tertiary = hyper.floors.floor_plan_microgrid }
  }

  local chosen = util.random_weighted_from("weight",weights)

  local gxm,gym = dgn.max_bounds()
  local build = {
    name = "Hyper Grid",
    build_fixture = {
      { pass = "Primary", type = "build", strategy = hyper.place.strategy_primary, max_rooms = 1, generators = {
        { generator = "code", paint_callback = chosen.primary, min_size_x = gxm-22, max_size_x = gxm-2, min_size_y = gym-22, max_size_y = gym-2, place_padding = 1 }
      } },
      { pass = "Secondary", type = "build", strategy = hyper.place.strategy_primary, max_rooms = 1, enabled = chosen.secondary ~= nil, generators = {
        { generator = "code", paint_callback = chosen.secondary, min_size_x = gxm-22, max_size_x = gxm-2, min_size_y = gym-22, max_size_y = gym-2, place_padding = 1 }
      } },
      { pass = "Tertiary", type = "build", strategy = hyper.place.strategy_primary, max_rooms = 1, enabled = chosen.tertiary ~= nil, generators = {
        { generator = "code", paint_callback = chosen.tertiary, min_size_x = gxm-22, max_size_x = gxm-2, min_size_y = gym-22, max_size_y = gym-2, place_padding = 1 }
      } }
    }
  }

  hyper.build_layout(_G,build)
  zonify.grid_fill_zones(1, "rock_wall")
}}
